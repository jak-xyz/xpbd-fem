#include "Fem.h"
#include "Xpbd.h"

//-----------------------------------------------------------------------------
// Precalculated FEM values at quadrature points for 1-3 point quadrature
template<FemShape Shape, uint32_t Points> constexpr uint32_t QuadratureWeights = 0;
template<> constexpr float QuadratureWeights<FemShape::Tri, 1>[1] = { 1.000000f, };
template<> constexpr float QuadratureWeights<FemShape::Tri, 3>[3] = { 0.333333f, 0.333333f, 0.333333f, };
template<> constexpr float QuadratureWeights<FemShape::Tri, 7>[7] = { 0.225000f, 0.132394f, 0.132394f, 0.132394f, 0.125939f, 0.125939f, 0.125939f, };
template<> constexpr float QuadratureWeights<FemShape::Tet, 1>[1] = { 1.000000f, };
template<> constexpr float QuadratureWeights<FemShape::Tet, 4>[4] = { 0.250000f, 0.250000f, 0.250000f, 0.250000f, };
template<> constexpr float QuadratureWeights<FemShape::Tet, 10>[10] = { 0.047633f, 0.047633f, 0.047633f, 0.047633f, 0.134911f, 0.134911f, 0.134911f, 0.134911f, 0.134911f, 0.134911f, };
template<> constexpr float QuadratureWeights<FemShape::Quad, 1>[1] = { 4.000000f, };
template<> constexpr float QuadratureWeights<FemShape::Quad, 4>[4] = { 1.000000f, 1.000000f, 1.000000f, 1.000000f, };
template<> constexpr float QuadratureWeights<FemShape::Quad, 9>[9] = { 0.308642f, 0.493828f, 0.308642f, 0.493828f, 0.790124f, 0.493828f, 0.308642f, 0.493828f, 0.308642f, };
template<> constexpr float QuadratureWeights<FemShape::Hex, 1>[1] = { 8.000000f, };
template<> constexpr float QuadratureWeights<FemShape::Hex, 8>[8] = { 1.000000f, 1.000000f, 1.000000f, 1.000000f, 1.000000f, 1.000000f, 1.000000f, 1.000000f, };
template<> constexpr float QuadratureWeights<FemShape::Hex, 27>[27] = { 0.171468f, 0.274349f, 0.171468f, 0.274349f, 0.438958f, 0.274349f, 0.171468f, 0.274349f, 0.171468f, 0.274349f, 0.438958f, 0.274349f, 0.438958f, 0.702332f, 0.438958f, 0.274349f, 0.438958f, 0.274349f, 0.171468f, 0.274349f, 0.171468f, 0.274349f, 0.438958f, 0.274349f, 0.171468f, 0.274349f, 0.171468f, };

template<FemShape Shape, uint32_t Nodes, uint32_t Points> constexpr uint32_t ShapeFunctions = 0;
template<> constexpr float ShapeFunctions<FemShape::Tri, 3, 1>[1][3] = { { 0.333333f, 0.333333f, 0.333333f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tri, 3, 3>[3][3] = { { 0.500000f, 0.500000f, 0.000000f, }, { 0.500000f, 0.000000f, 0.500000f, }, { 0.000000f, 0.500000f, 0.500000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tri, 3, 7>[7][3] = { { 0.333333f, 0.333333f, 0.333333f, }, { 0.059716f, 0.470142f, 0.470142f, }, { 0.470142f, 0.059716f, 0.470142f, }, { 0.470142f, 0.470142f, 0.059716f, }, { 0.797427f, 0.101287f, 0.101287f, }, { 0.101287f, 0.797427f, 0.101287f, }, { 0.101287f, 0.101287f, 0.797427f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tri, 6, 1>[1][6] = { { -0.111111f, -0.111111f, -0.111111f, 0.444444f, 0.444444f, 0.444444f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tri, 6, 3>[3][6] = { { 0.000000f, 0.000000f, -0.000000f, 1.000000f, 0.000000f, 0.000000f, }, { 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tri, 6, 7>[7][6] = { { -0.111111f, -0.111111f, -0.111111f, 0.444444f, 0.444444f, 0.444444f, }, { -0.052584f, -0.028075f, -0.028075f, 0.112300f, 0.884134f, 0.112300f, }, { -0.028075f, -0.052584f, -0.028075f, 0.112300f, 0.112300f, 0.884134f, }, { -0.028075f, -0.028075f, -0.052584f, 0.884134f, 0.112300f, 0.112300f, }, { 0.474353f, -0.080769f, -0.080769f, 0.323074f, 0.041036f, 0.323074f, }, { -0.080769f, 0.474353f, -0.080769f, 0.323074f, 0.323074f, 0.041036f, }, { -0.080769f, -0.080769f, 0.474353f, 0.041036f, 0.323074f, 0.323074f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tet, 4, 1>[1][4] = { { 0.250000f, 0.250000f, 0.250000f, 0.250000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tet, 4, 4>[4][4] = { { 0.585410f, 0.138197f, 0.138197f, 0.138197f, }, { 0.138197f, 0.585410f, 0.138197f, 0.138197f, }, { 0.138197f, 0.138197f, 0.585410f, 0.138197f, }, { 0.138197f, 0.138197f, 0.138197f, 0.585410f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tet, 4, 10>[10][4] = { { 0.778495f, 0.073835f, 0.073835f, 0.073835f, }, { 0.073835f, 0.778495f, 0.073835f, 0.073835f, }, { 0.073835f, 0.073835f, 0.778495f, 0.073835f, }, { 0.073835f, 0.073835f, 0.073835f, 0.778495f, }, { 0.406244f, 0.406244f, 0.093756f, 0.093756f, }, { 0.406244f, 0.093756f, 0.406244f, 0.093756f, }, { 0.406244f, 0.093756f, 0.093756f, 0.406244f, }, { 0.093756f, 0.406244f, 0.406244f, 0.093756f, }, { 0.093756f, 0.406244f, 0.093756f, 0.406244f, }, { 0.093756f, 0.093756f, 0.406244f, 0.406244f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tet, 10, 1>[1][10] = { { -0.125000f, -0.125000f, -0.125000f, -0.125000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tet, 10, 4>[4][10] = { { 0.100000f, -0.100000f, -0.100000f, -0.100000f, 0.323607f, 0.323607f, 0.323607f, 0.076393f, 0.076393f, 0.076393f, }, { -0.100000f, 0.100000f, -0.100000f, -0.100000f, 0.323607f, 0.076393f, 0.076393f, 0.323607f, 0.323607f, 0.076393f, }, { -0.100000f, -0.100000f, 0.100000f, -0.100000f, 0.076393f, 0.323607f, 0.076393f, 0.323607f, 0.076393f, 0.323607f, }, { -0.100000f, -0.100000f, -0.100000f, 0.100000f, 0.076393f, 0.076393f, 0.323607f, 0.076393f, 0.323607f, 0.323607f, }, };
template<> constexpr float ShapeFunctions<FemShape::Tet, 10, 10>[10][10] = { { 0.433615f, -0.062932f, -0.062932f, -0.062932f, 0.229921f, 0.229921f, 0.229921f, 0.021806f, 0.021806f, 0.021806f, }, { -0.062932f, 0.433615f, -0.062932f, -0.062932f, 0.229921f, 0.021806f, 0.021806f, 0.229921f, 0.229921f, 0.021806f, }, { -0.062932f, -0.062932f, 0.433615f, -0.062932f, 0.021806f, 0.229921f, 0.021806f, 0.229921f, 0.021806f, 0.229921f, }, { -0.062932f, -0.062932f, -0.062932f, 0.433615f, 0.021806f, 0.021806f, 0.229921f, 0.021806f, 0.229921f, 0.229921f, }, { -0.076175f, -0.076175f, -0.076175f, -0.076175f, 0.660138f, 0.152351f, 0.152351f, 0.152351f, 0.152351f, 0.035160f, }, { -0.076175f, -0.076175f, -0.076175f, -0.076175f, 0.152351f, 0.660138f, 0.152351f, 0.152351f, 0.035160f, 0.152351f, }, { -0.076175f, -0.076175f, -0.076175f, -0.076175f, 0.152351f, 0.152351f, 0.660138f, 0.035160f, 0.152351f, 0.152351f, }, { -0.076175f, -0.076175f, -0.076175f, -0.076175f, 0.152351f, 0.152351f, 0.035160f, 0.660138f, 0.152351f, 0.152351f, }, { -0.076175f, -0.076175f, -0.076175f, -0.076175f, 0.152351f, 0.035160f, 0.152351f, 0.152351f, 0.660138f, 0.152351f, }, { -0.076175f, -0.076175f, -0.076175f, -0.076175f, 0.035160f, 0.152351f, 0.152351f, 0.152351f, 0.152351f, 0.660138f, }, };
template<> constexpr float ShapeFunctions<FemShape::Quad, 4, 1>[1][4] = { { 0.250000f, 0.250000f, 0.250000f, 0.250000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Quad, 4, 4>[4][4] = { { 0.622008f, 0.166667f, 0.044658f, 0.166667f, }, { 0.166667f, 0.622008f, 0.166667f, 0.044658f, }, { 0.166667f, 0.044658f, 0.166667f, 0.622008f, }, { 0.044658f, 0.166667f, 0.622008f, 0.166667f, }, };
template<> constexpr float ShapeFunctions<FemShape::Quad, 4, 9>[9][4] = { { 0.787299f, 0.100000f, 0.012702f, 0.100000f, }, { 0.443649f, 0.443649f, 0.056351f, 0.056351f, }, { 0.100000f, 0.787299f, 0.100000f, 0.012702f, }, { 0.443649f, 0.056351f, 0.056351f, 0.443649f, }, { 0.250000f, 0.250000f, 0.250000f, 0.250000f, }, { 0.056351f, 0.443649f, 0.443649f, 0.056351f, }, { 0.100000f, 0.012702f, 0.100000f, 0.787299f, }, { 0.056351f, 0.056351f, 0.443649f, 0.443649f, }, { 0.012702f, 0.100000f, 0.787299f, 0.100000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Quad, 9, 1>[1][9] = { { 0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 1.000000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Quad, 9, 4>[4][9] = { { 0.207336f, -0.055556f, 0.014886f, -0.055556f, 0.303561f, -0.081339f, -0.081339f, 0.303561f, 0.444445f, }, { -0.055556f, 0.207336f, -0.055556f, 0.014886f, 0.303561f, 0.303561f, -0.081339f, -0.081339f, 0.444445f, }, { -0.055556f, 0.014886f, -0.055556f, 0.207336f, -0.081339f, -0.081339f, 0.303561f, 0.303561f, 0.444445f, }, { 0.014886f, -0.055556f, 0.207336f, -0.055556f, -0.081339f, 0.303561f, 0.303561f, -0.081339f, 0.444445f, }, };
template<> constexpr float ShapeFunctions<FemShape::Quad, 9, 9>[9][9] = { { 0.472380f, -0.060000f, 0.007621f, -0.060000f, 0.274919f, -0.034919f, -0.034919f, 0.274919f, 0.160000f, }, { -0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.687299f, 0.000000f, -0.087298f, -0.000000f, 0.399999f, }, { -0.060000f, 0.472380f, -0.060000f, 0.007621f, 0.274919f, 0.274919f, -0.034919f, -0.034919f, 0.160000f, }, { -0.000000f, 0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.087298f, 0.000000f, 0.687299f, 0.399999f, }, { 0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 1.000000f, }, { 0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.687299f, 0.000000f, -0.087298f, 0.399999f, }, { -0.060000f, 0.007621f, -0.060000f, 0.472380f, -0.034919f, -0.034919f, 0.274919f, 0.274919f, 0.160000f, }, { 0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.087298f, 0.000000f, 0.687299f, -0.000000f, 0.399999f, }, { 0.007621f, -0.060000f, 0.472380f, -0.060000f, -0.034919f, 0.274919f, 0.274919f, -0.034919f, 0.160000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Hex, 8, 1>[1][8] = { { 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Hex, 8, 8>[8][8] = { { 0.490562f, 0.131446f, 0.131446f, 0.035221f, 0.131446f, 0.035221f, 0.035221f, 0.009437f, }, { 0.131446f, 0.490562f, 0.035221f, 0.131446f, 0.035221f, 0.131446f, 0.009437f, 0.035221f, }, { 0.131446f, 0.035221f, 0.490562f, 0.131446f, 0.035221f, 0.009437f, 0.131446f, 0.035221f, }, { 0.035221f, 0.131446f, 0.131446f, 0.490562f, 0.009437f, 0.035221f, 0.035221f, 0.131446f, }, { 0.131446f, 0.035221f, 0.035221f, 0.009437f, 0.490562f, 0.131446f, 0.131446f, 0.035221f, }, { 0.035221f, 0.131446f, 0.009437f, 0.035221f, 0.131446f, 0.490562f, 0.035221f, 0.131446f, }, { 0.035221f, 0.009437f, 0.131446f, 0.035221f, 0.131446f, 0.035221f, 0.490562f, 0.131446f, }, { 0.009437f, 0.035221f, 0.035221f, 0.131446f, 0.035221f, 0.131446f, 0.131446f, 0.490562f, }, };
template<> constexpr float ShapeFunctions<FemShape::Hex, 8, 27>[27][8] = { { 0.698569f, 0.088730f, 0.088730f, 0.011270f, 0.088730f, 0.011270f, 0.011270f, 0.001431f, }, { 0.393649f, 0.393649f, 0.050000f, 0.050000f, 0.050000f, 0.050000f, 0.006351f, 0.006351f, }, { 0.088730f, 0.698569f, 0.011270f, 0.088730f, 0.011270f, 0.088730f, 0.001431f, 0.011270f, }, { 0.393649f, 0.050000f, 0.393649f, 0.050000f, 0.050000f, 0.006351f, 0.050000f, 0.006351f, }, { 0.221825f, 0.221825f, 0.221825f, 0.221825f, 0.028175f, 0.028175f, 0.028175f, 0.028175f, }, { 0.050000f, 0.393649f, 0.050000f, 0.393649f, 0.006351f, 0.050000f, 0.006351f, 0.050000f, }, { 0.088730f, 0.011270f, 0.698569f, 0.088730f, 0.011270f, 0.001431f, 0.088730f, 0.011270f, }, { 0.050000f, 0.050000f, 0.393649f, 0.393649f, 0.006351f, 0.006351f, 0.050000f, 0.050000f, }, { 0.011270f, 0.088730f, 0.088730f, 0.698569f, 0.001431f, 0.011270f, 0.011270f, 0.088730f, }, { 0.393649f, 0.050000f, 0.050000f, 0.006351f, 0.393649f, 0.050000f, 0.050000f, 0.006351f, }, { 0.221825f, 0.221825f, 0.028175f, 0.028175f, 0.221825f, 0.221825f, 0.028175f, 0.028175f, }, { 0.050000f, 0.393649f, 0.006351f, 0.050000f, 0.050000f, 0.393649f, 0.006351f, 0.050000f, }, { 0.221825f, 0.028175f, 0.221825f, 0.028175f, 0.221825f, 0.028175f, 0.221825f, 0.028175f, }, { 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, 0.125000f, }, { 0.028175f, 0.221825f, 0.028175f, 0.221825f, 0.028175f, 0.221825f, 0.028175f, 0.221825f, }, { 0.050000f, 0.006351f, 0.393649f, 0.050000f, 0.050000f, 0.006351f, 0.393649f, 0.050000f, }, { 0.028175f, 0.028175f, 0.221825f, 0.221825f, 0.028175f, 0.028175f, 0.221825f, 0.221825f, }, { 0.006351f, 0.050000f, 0.050000f, 0.393649f, 0.006351f, 0.050000f, 0.050000f, 0.393649f, }, { 0.088730f, 0.011270f, 0.011270f, 0.001431f, 0.698569f, 0.088730f, 0.088730f, 0.011270f, }, { 0.050000f, 0.050000f, 0.006351f, 0.006351f, 0.393649f, 0.393649f, 0.050000f, 0.050000f, }, { 0.011270f, 0.088730f, 0.001431f, 0.011270f, 0.088730f, 0.698569f, 0.011270f, 0.088730f, }, { 0.050000f, 0.006351f, 0.050000f, 0.006351f, 0.393649f, 0.050000f, 0.393649f, 0.050000f, }, { 0.028175f, 0.028175f, 0.028175f, 0.028175f, 0.221825f, 0.221825f, 0.221825f, 0.221825f, }, { 0.006351f, 0.050000f, 0.006351f, 0.050000f, 0.050000f, 0.393649f, 0.050000f, 0.393649f, }, { 0.011270f, 0.001431f, 0.088730f, 0.011270f, 0.088730f, 0.011270f, 0.698569f, 0.088730f, }, { 0.006351f, 0.006351f, 0.050000f, 0.050000f, 0.050000f, 0.050000f, 0.393649f, 0.393649f, }, { 0.001431f, 0.011270f, 0.011270f, 0.088730f, 0.011270f, 0.088730f, 0.088730f, 0.698569f, }, };
template<> constexpr float ShapeFunctions<FemShape::Hex, 27, 1>[1][27] = { { -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 1.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, }, };
template<> constexpr float ShapeFunctions<FemShape::Hex, 27, 8>[8][27] = { { 0.094409f, 0.138224f, -0.025297f, 0.138224f, 0.202374f, -0.037037f, -0.025297f, -0.037037f, 0.006778f, 0.138224f, 0.202374f, -0.037037f, 0.202374f, 0.296297f, -0.054226f, -0.037037f, -0.054226f, 0.009924f, -0.025297f, -0.037037f, 0.006778f, -0.037037f, -0.054226f, 0.009924f, 0.006778f, 0.009924f, -0.001816f, }, { -0.025297f, 0.138224f, 0.094409f, -0.037037f, 0.202374f, 0.138224f, 0.006778f, -0.037037f, -0.025297f, -0.037037f, 0.202374f, 0.138224f, -0.054226f, 0.296297f, 0.202374f, 0.009924f, -0.054226f, -0.037037f, 0.006778f, -0.037037f, -0.025297f, 0.009924f, -0.054226f, -0.037037f, -0.001816f, 0.009924f, 0.006778f, }, { -0.025297f, -0.037037f, 0.006778f, 0.138224f, 0.202374f, -0.037037f, 0.094409f, 0.138224f, -0.025297f, -0.037037f, -0.054226f, 0.009924f, 0.202374f, 0.296297f, -0.054226f, 0.138224f, 0.202374f, -0.037037f, 0.006778f, 0.009924f, -0.001816f, -0.037037f, -0.054226f, 0.009924f, -0.025297f, -0.037037f, 0.006778f, }, { 0.006778f, -0.037037f, -0.025297f, -0.037037f, 0.202374f, 0.138224f, -0.025297f, 0.138224f, 0.094409f, 0.009924f, -0.054226f, -0.037037f, -0.054226f, 0.296297f, 0.202374f, -0.037037f, 0.202374f, 0.138224f, -0.001816f, 0.009924f, 0.006778f, 0.009924f, -0.054226f, -0.037037f, 0.006778f, -0.037037f, -0.025297f, }, { -0.025297f, -0.037037f, 0.006778f, -0.037037f, -0.054226f, 0.009924f, 0.006778f, 0.009924f, -0.001816f, 0.138224f, 0.202374f, -0.037037f, 0.202374f, 0.296297f, -0.054226f, -0.037037f, -0.054226f, 0.009924f, 0.094409f, 0.138224f, -0.025297f, 0.138224f, 0.202374f, -0.037037f, -0.025297f, -0.037037f, 0.006778f, }, { 0.006778f, -0.037037f, -0.025297f, 0.009924f, -0.054226f, -0.037037f, -0.001816f, 0.009924f, 0.006778f, -0.037037f, 0.202374f, 0.138224f, -0.054226f, 0.296297f, 0.202374f, 0.009924f, -0.054226f, -0.037037f, -0.025297f, 0.138224f, 0.094409f, -0.037037f, 0.202374f, 0.138224f, 0.006778f, -0.037037f, -0.025297f, }, { 0.006778f, 0.009924f, -0.001816f, -0.037037f, -0.054226f, 0.009924f, -0.025297f, -0.037037f, 0.006778f, -0.037037f, -0.054226f, 0.009924f, 0.202374f, 0.296297f, -0.054226f, 0.138224f, 0.202374f, -0.037037f, -0.025297f, -0.037037f, 0.006778f, 0.138224f, 0.202374f, -0.037037f, 0.094409f, 0.138224f, -0.025297f, }, { -0.001816f, 0.009924f, 0.006778f, 0.009924f, -0.054226f, -0.037037f, 0.006778f, -0.037037f, -0.025297f, 0.009924f, -0.054226f, -0.037037f, -0.054226f, 0.296297f, 0.202374f, -0.037037f, 0.202374f, 0.138224f, 0.006778f, -0.037037f, -0.025297f, -0.037037f, 0.202374f, 0.138224f, -0.025297f, 0.138224f, 0.094409f, }, };
template<> constexpr float ShapeFunctions<FemShape::Hex, 27, 27>[27][27] = {
	{ 0.324666f, 0.188952f, -0.041238f, 0.188952f, 0.109968f, -0.024000f, -0.041238f, -0.024000f, 0.005238f, 0.188952f, 0.109968f, -0.024000f, 0.109968f, 0.064000f, -0.013968f, -0.024000f, -0.013968f, 0.003048f, -0.041238f, -0.024000f, 0.005238f, -0.024000f, -0.013968f, 0.003048f, 0.005238f, 0.003048f, -0.000665f, }, { -0.000000f, 0.472380f, 0.000000f, -0.000000f, 0.274919f, 0.000000f, 0.000000f, -0.060000f, -0.000000f, -0.000000f, 0.274919f, 0.000000f, -0.000000f, 0.160000f, 0.000000f, 0.000000f, -0.034919f, -0.000000f, 0.000000f, -0.060000f, -0.000000f, 0.000000f, -0.034919f, -0.000000f, -0.000000f, 0.007621f, 0.000000f, }, { -0.041238f, 0.188952f, 0.324666f, -0.024000f, 0.109968f, 0.188952f, 0.005238f, -0.024000f, -0.041238f, -0.024000f, 0.109968f, 0.188952f, -0.013968f, 0.064000f, 0.109968f, 0.003048f, -0.013968f, -0.024000f, 0.005238f, -0.024000f, -0.041238f, 0.003048f, -0.013968f, -0.024000f, -0.000665f, 0.003048f, 0.005238f, }, { -0.000000f, -0.000000f, 0.000000f, 0.472380f, 0.274919f, -0.060000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.274919f, 0.160000f, -0.034919f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.060000f, -0.034919f, 0.007621f, -0.000000f, -0.000000f, 0.000000f, }, { 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.687299f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.399999f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.087298f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, }, { 0.000000f, -0.000000f, -0.000000f, -0.060000f, 0.274919f, 0.472380f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.034919f, 0.160000f, 0.274919f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.007621f, -0.034919f, -0.060000f, 0.000000f, -0.000000f, -0.000000f, }, { -0.041238f, -0.024000f, 0.005238f, 0.188952f, 0.109968f, -0.024000f, 0.324666f, 0.188952f, -0.041238f, -0.024000f, -0.013968f, 0.003048f, 0.109968f, 0.064000f, -0.013968f, 0.188952f, 0.109968f, -0.024000f, 0.005238f, 0.003048f, -0.000665f, -0.024000f, -0.013968f, 0.003048f, -0.041238f, -0.024000f, 0.005238f, }, { 0.000000f, -0.060000f, -0.000000f, -0.000000f, 0.274919f, 0.000000f, -0.000000f, 0.472380f, 0.000000f, 0.000000f, -0.034919f, -0.000000f, -0.000000f, 0.160000f, 0.000000f, -0.000000f, 0.274919f, 0.000000f, -0.000000f, 0.007621f, 0.000000f, 0.000000f, -0.034919f, -0.000000f, 0.000000f, -0.060000f, -0.000000f, }, { 0.005238f, -0.024000f, -0.041238f, -0.024000f, 0.109968f, 0.188952f, -0.041238f, 0.188952f, 0.324666f, 0.003048f, -0.013968f, -0.024000f, -0.013968f, 0.064000f, 0.109968f, -0.024000f, 0.109968f, 0.188952f, -0.000665f, 0.003048f, 0.005238f, 0.003048f, -0.013968f, -0.024000f, 0.005238f, -0.024000f, -0.041238f, },
	{ -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.472380f, 0.274919f, -0.060000f, 0.274919f, 0.160000f, -0.034919f, -0.060000f, -0.034919f, 0.007621f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, }, { 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.687299f, 0.000000f, -0.000000f, 0.399999f, 0.000000f, 0.000000f, -0.087298f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, }, { 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.060000f, 0.274919f, 0.472380f, -0.034919f, 0.160000f, 0.274919f, 0.007621f, -0.034919f, -0.060000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, }, { 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.687299f, 0.399999f, -0.087298f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 1.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.087298f, 0.399999f, 0.687299f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, }, { 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.060000f, -0.034919f, 0.007621f, 0.274919f, 0.160000f, -0.034919f, 0.472380f, 0.274919f, -0.060000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.087298f, -0.000000f, -0.000000f, 0.399999f, 0.000000f, -0.000000f, 0.687299f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.007621f, -0.034919f, -0.060000f, -0.034919f, 0.160000f, 0.274919f, -0.060000f, 0.274919f, 0.472380f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, },
	{ -0.041238f, -0.024000f, 0.005238f, -0.024000f, -0.013968f, 0.003048f, 0.005238f, 0.003048f, -0.000665f, 0.188952f, 0.109968f, -0.024000f, 0.109968f, 0.064000f, -0.013968f, -0.024000f, -0.013968f, 0.003048f, 0.324666f, 0.188952f, -0.041238f, 0.188952f, 0.109968f, -0.024000f, -0.041238f, -0.024000f, 0.005238f, }, { 0.000000f, -0.060000f, -0.000000f, 0.000000f, -0.034919f, -0.000000f, -0.000000f, 0.007621f, 0.000000f, -0.000000f, 0.274919f, 0.000000f, -0.000000f, 0.160000f, 0.000000f, 0.000000f, -0.034919f, -0.000000f, -0.000000f, 0.472380f, 0.000000f, -0.000000f, 0.274919f, 0.000000f, 0.000000f, -0.060000f, -0.000000f, }, { 0.005238f, -0.024000f, -0.041238f, 0.003048f, -0.013968f, -0.024000f, -0.000665f, 0.003048f, 0.005238f, -0.024000f, 0.109968f, 0.188952f, -0.013968f, 0.064000f, 0.109968f, 0.003048f, -0.013968f, -0.024000f, -0.041238f, 0.188952f, 0.324666f, -0.024000f, 0.109968f, 0.188952f, 0.005238f, -0.024000f, -0.041238f, }, { 0.000000f, 0.000000f, -0.000000f, -0.060000f, -0.034919f, 0.007621f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.274919f, 0.160000f, -0.034919f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.000000f, 0.472380f, 0.274919f, -0.060000f, 0.000000f, 0.000000f, -0.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.087298f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.399999f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.000000f, 0.687299f, 0.000000f, -0.000000f, 0.000000f, 0.000000f, }, { -0.000000f, 0.000000f, 0.000000f, 0.007621f, -0.034919f, -0.060000f, 0.000000f, -0.000000f, -0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.034919f, 0.160000f, 0.274919f, -0.000000f, 0.000000f, 0.000000f, 0.000000f, -0.000000f, -0.000000f, -0.060000f, 0.274919f, 0.472380f, -0.000000f, 0.000000f, 0.000000f, }, { 0.005238f, 0.003048f, -0.000665f, -0.024000f, -0.013968f, 0.003048f, -0.041238f, -0.024000f, 0.005238f, -0.024000f, -0.013968f, 0.003048f, 0.109968f, 0.064000f, -0.013968f, 0.188952f, 0.109968f, -0.024000f, -0.041238f, -0.024000f, 0.005238f, 0.188952f, 0.109968f, -0.024000f, 0.324666f, 0.188952f, -0.041238f, }, { -0.000000f, 0.007621f, 0.000000f, 0.000000f, -0.034919f, -0.000000f, 0.000000f, -0.060000f, -0.000000f, 0.000000f, -0.034919f, -0.000000f, -0.000000f, 0.160000f, 0.000000f, -0.000000f, 0.274919f, 0.000000f, 0.000000f, -0.060000f, -0.000000f, -0.000000f, 0.274919f, 0.000000f, -0.000000f, 0.472380f, 0.000000f, }, { -0.000665f, 0.003048f, 0.005238f, 0.003048f, -0.013968f, -0.024000f, 0.005238f, -0.024000f, -0.041238f, 0.003048f, -0.013968f, -0.024000f, -0.013968f, 0.064000f, 0.109968f, -0.024000f, 0.109968f, 0.188952f, 0.005238f, -0.024000f, -0.041238f, -0.024000f, 0.109968f, 0.188952f, -0.041238f, 0.188952f, 0.324666f, }, };

template<FemShape Shape, uint32_t Nodes, uint32_t Points> constexpr uint32_t ShapeFunctionGradients = 0;
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Tri, 3, 1>[1][3] = { { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Tri, 3, 3>[3][3] = { { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Tri, 3, 7>[7][3] = { { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Tri, 6, 1>[1][6] = { { vec2(0.333333f, 0.000000f), vec2(0.000000f, 0.333333f), vec2(-0.333333f,-0.333333f), vec2(1.333333f, 1.333333f), vec2(-1.333333f, 0.000000f), vec2(0.000000f,-1.333333f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Tri, 6, 3>[3][6] = { { vec2(1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(1.000000f, 1.000000f), vec2(2.000000f, 2.000000f), vec2(-2.000000f,-2.000000f), vec2(-2.000000f,-2.000000f), }, { vec2(1.000000f, 0.000000f), vec2(0.000000f,-1.000000f), vec2(-1.000000f,-1.000000f), vec2(0.000000f, 2.000000f), vec2(-0.000000f, 2.000000f), vec2(0.000000f,-2.000000f), }, { vec2(-1.000000f, 0.000000f), vec2(0.000000f, 1.000000f), vec2(-1.000000f,-1.000000f), vec2(2.000000f, 0.000000f), vec2(-2.000000f, 0.000000f), vec2(2.000000f,-0.000000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Tri, 6, 7>[7][6] = { { vec2(0.333333f, 0.000000f), vec2(0.000000f, 0.333333f), vec2(-0.333333f,-0.333333f), vec2(1.333333f, 1.333333f), vec2(-1.333333f, 0.000000f), vec2(0.000000f,-1.333333f), }, { vec2(-0.761137f, 0.000000f), vec2(0.000000f, 0.880568f), vec2(-0.880568f,-0.880568f), vec2(1.880568f, 0.238863f), vec2(-1.880568f, 0.000000f), vec2(1.641705f,-0.238863f), }, { vec2(0.880568f, 0.000000f), vec2(0.000000f,-0.761137f), vec2(-0.880568f,-0.880568f), vec2(0.238863f, 1.880568f), vec2(-0.238863f, 1.641705f), vec2(0.000000f,-1.880568f), }, { vec2(0.880568f, 0.000000f), vec2(0.000000f, 0.880568f), vec2(0.761137f, 0.761137f), vec2(1.880568f, 1.880568f), vec2(-1.880568f,-1.641705f), vec2(-1.641705f,-1.880568f), }, { vec2(2.189708f, 0.000000f), vec2(0.000000f,-0.594854f), vec2(0.594854f, 0.594854f), vec2(0.405146f, 3.189708f), vec2(-0.405146f, 0.000000f), vec2(-2.784562f,-3.189708f), }, { vec2(-0.594854f, 0.000000f), vec2(0.000000f, 2.189708f), vec2(0.594854f, 0.594854f), vec2(3.189708f, 0.405146f), vec2(-3.189708f,-2.784562f), vec2(0.000000f,-0.405146f), }, { vec2(-0.594854f, 0.000000f), vec2(0.000000f,-0.594854f), vec2(-2.189708f,-2.189708f), vec2(0.405146f, 0.405146f), vec2(-0.405146f, 2.784562f), vec2(2.784562f,-0.405146f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Tet, 4, 1>[1][4] = { { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Tet, 4, 4>[4][4] = { { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Tet, 4, 10>[10][4] = { { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, { vec3(1.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 1.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 1.000000f), vec3(-1.000000f,-1.000000f,-1.000000f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Tet, 10, 1>[1][10] = { { vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(1.000000f, 1.000000f, 0.000000f), vec3(1.000000f, 0.000000f, 1.000000f), vec3(0.000000f,-1.000000f,-1.000000f), vec3(0.000000f, 1.000000f, 1.000000f), vec3(-1.000000f, 0.000000f,-1.000000f), vec3(-1.000000f,-1.000000f, 0.000000f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Tet, 10, 4>[4][10] = { { vec3(1.341641f, 0.000000f, 0.000000f), vec3(0.000000f,-0.447214f, 0.000000f), vec3(0.000000f, 0.000000f,-0.447214f), vec3(0.447214f, 0.447214f, 0.447214f), vec3(0.552786f, 2.341641f, 0.000000f), vec3(0.552786f, 0.000000f, 2.341641f), vec3(-1.788854f,-2.341641f,-2.341641f), vec3(0.000000f, 0.552786f, 0.552786f), vec3(-0.552786f, 0.000000f,-0.552786f), vec3(-0.552786f,-0.552786f, 0.000000f), }, { vec3(-0.447214f, 0.000000f, 0.000000f), vec3(0.000000f, 1.341641f, 0.000000f), vec3(0.000000f, 0.000000f,-0.447214f), vec3(0.447214f, 0.447214f, 0.447214f), vec3(2.341641f, 0.552786f, 0.000000f), vec3(0.552786f, 0.000000f, 0.552786f), vec3(0.000000f,-0.552786f,-0.552786f), vec3(0.000000f, 0.552786f, 2.341641f), vec3(-2.341641f,-1.788854f,-2.341641f), vec3(-0.552786f,-0.552786f, 0.000000f), }, { vec3(-0.447214f, 0.000000f, 0.000000f), vec3(0.000000f,-0.447214f, 0.000000f), vec3(0.000000f, 0.000000f, 1.341641f), vec3(0.447214f, 0.447214f, 0.447214f), vec3(0.552786f, 0.552786f, 0.000000f), vec3(2.341641f, 0.000000f, 0.552786f), vec3(0.000000f,-0.552786f,-0.552786f), vec3(0.000000f, 2.341641f, 0.552786f), vec3(-0.552786f, 0.000000f,-0.552786f), vec3(-2.341641f,-2.341641f,-1.788854f), }, { vec3(-0.447214f, 0.000000f, 0.000000f), vec3(0.000000f,-0.447214f, 0.000000f), vec3(0.000000f, 0.000000f,-0.447214f), vec3(-1.341641f,-1.341641f,-1.341641f), vec3(0.552786f, 0.552786f, 0.000000f), vec3(0.552786f, 0.000000f, 0.552786f), vec3(1.788854f,-0.552786f,-0.552786f), vec3(0.000000f, 0.552786f, 0.552786f), vec3(-0.552786f, 1.788854f,-0.552786f), vec3(-0.552786f,-0.552786f, 1.788854f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Tet, 10, 10>[10][10] = { { vec3(2.113981f, 0.000000f, 0.000000f), vec3(0.000000f,-0.704660f, 0.000000f), vec3(0.000000f, 0.000000f,-0.704660f), vec3(0.704660f, 0.704660f, 0.704660f), vec3(0.295340f, 3.113981f, 0.000000f), vec3(0.295340f, 0.000000f, 3.113981f), vec3(-2.818642f,-3.113981f,-3.113981f), vec3(0.000000f, 0.295340f, 0.295340f), vec3(-0.295340f, 0.000000f,-0.295340f), vec3(-0.295340f,-0.295340f, 0.000000f), }, { vec3(-0.704660f, 0.000000f, 0.000000f), vec3(0.000000f, 2.113981f, 0.000000f), vec3(0.000000f, 0.000000f,-0.704660f), vec3(0.704660f, 0.704660f, 0.704660f), vec3(3.113981f, 0.295340f, 0.000000f), vec3(0.295340f, 0.000000f, 0.295340f), vec3(0.000000f,-0.295340f,-0.295340f), vec3(0.000000f, 0.295340f, 3.113981f), vec3(-3.113981f,-2.818642f,-3.113981f), vec3(-0.295340f,-0.295340f, 0.000000f), }, { vec3(-0.704660f, 0.000000f, 0.000000f), vec3(0.000000f,-0.704660f, 0.000000f), vec3(0.000000f, 0.000000f, 2.113981f), vec3(0.704660f, 0.704660f, 0.704660f), vec3(0.295340f, 0.295340f, 0.000000f), vec3(3.113981f, 0.000000f, 0.295340f), vec3(0.000000f,-0.295340f,-0.295340f), vec3(0.000000f, 3.113981f, 0.295340f), vec3(-0.295340f, 0.000000f,-0.295340f), vec3(-3.113981f,-3.113981f,-2.818642f), }, { vec3(-0.704660f, 0.000000f, 0.000000f), vec3(0.000000f,-0.704660f, 0.000000f), vec3(0.000000f, 0.000000f,-0.704660f), vec3(-2.113981f,-2.113981f,-2.113981f), vec3(0.295340f, 0.295340f, 0.000000f), vec3(0.295340f, 0.000000f, 0.295340f), vec3(2.818642f,-0.295340f,-0.295340f), vec3(0.000000f, 0.295340f, 0.295340f), vec3(-0.295340f, 2.818642f,-0.295340f), vec3(-0.295340f,-0.295340f, 2.818642f), }, { vec3(0.624977f, 0.000000f, 0.000000f), vec3(0.000000f, 0.624977f, 0.000000f), vec3(0.000000f, 0.000000f,-0.624977f), vec3(0.624977f, 0.624977f, 0.624977f), vec3(1.624977f, 1.624977f, 0.000000f), vec3(0.375023f, 0.000000f, 1.624977f), vec3(-1.249955f,-1.624977f,-1.624977f), vec3(0.000000f, 0.375023f, 1.624977f), vec3(-1.624977f,-1.249955f,-1.624977f), vec3(-0.375023f,-0.375023f, 0.000000f), }, { vec3(0.624977f, 0.000000f, 0.000000f), vec3(0.000000f,-0.624977f, 0.000000f), vec3(0.000000f, 0.000000f, 0.624977f), vec3(0.624977f, 0.624977f, 0.624977f), vec3(0.375023f, 1.624977f, 0.000000f), vec3(1.624977f, 0.000000f, 1.624977f), vec3(-1.249955f,-1.624977f,-1.624977f), vec3(0.000000f, 1.624977f, 0.375023f), vec3(-0.375023f, 0.000000f,-0.375023f), vec3(-1.624977f,-1.624977f,-1.249955f), }, { vec3(0.624977f, 0.000000f, 0.000000f), vec3(0.000000f,-0.624977f, 0.000000f), vec3(0.000000f, 0.000000f,-0.624977f), vec3(-0.624977f,-0.624977f,-0.624977f), vec3(0.375023f, 1.624977f, 0.000000f), vec3(0.375023f, 0.000000f, 1.624977f), vec3(0.000000f,-1.624977f,-1.624977f), vec3(0.000000f, 0.375023f, 0.375023f), vec3(-0.375023f, 1.249955f,-0.375023f), vec3(-0.375023f,-0.375023f, 1.249955f), }, { vec3(-0.624977f, 0.000000f, 0.000000f), vec3(0.000000f, 0.624977f, 0.000000f), vec3(0.000000f, 0.000000f, 0.624977f), vec3(0.624977f, 0.624977f, 0.624977f), vec3(1.624977f, 0.375023f, 0.000000f), vec3(1.624977f, 0.000000f, 0.375023f), vec3(0.000000f,-0.375023f,-0.375023f), vec3(0.000000f, 1.624977f, 1.624977f), vec3(-1.624977f,-1.249955f,-1.624977f), vec3(-1.624977f,-1.624977f,-1.249955f), }, { vec3(-0.624977f, 0.000000f, 0.000000f), vec3(0.000000f, 0.624977f, 0.000000f), vec3(0.000000f, 0.000000f,-0.624977f), vec3(-0.624977f,-0.624977f,-0.624977f), vec3(1.624977f, 0.375023f, 0.000000f), vec3(0.375023f, 0.000000f, 0.375023f), vec3(1.249955f,-0.375023f,-0.375023f), vec3(0.000000f, 0.375023f, 1.624977f), vec3(-1.624977f, 0.000000f,-1.624977f), vec3(-0.375023f,-0.375023f, 1.249955f), }, { vec3(-0.624977f, 0.000000f, 0.000000f), vec3(0.000000f,-0.624977f, 0.000000f), vec3(0.000000f, 0.000000f, 0.624977f), vec3(-0.624977f,-0.624977f,-0.624977f), vec3(0.375023f, 0.375023f, 0.000000f), vec3(1.624977f, 0.000000f, 0.375023f), vec3(1.249955f,-0.375023f,-0.375023f), vec3(0.000000f, 1.624977f, 0.375023f), vec3(-0.375023f, 1.249955f,-0.375023f), vec3(-1.624977f,-1.624977f, 0.000000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Quad, 4, 1>[1][4] = { { vec2(-0.250000f,-0.250000f), vec2(0.250000f,-0.250000f), vec2(0.250000f, 0.250000f), vec2(-0.250000f, 0.250000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Quad, 4, 4>[4][4] = { { vec2(-0.394338f,-0.394338f), vec2(0.394338f,-0.105662f), vec2(0.105662f, 0.105662f), vec2(-0.105662f, 0.394338f), }, { vec2(-0.394338f,-0.105662f), vec2(0.394338f,-0.394338f), vec2(0.105662f, 0.394338f), vec2(-0.105662f, 0.105662f), }, { vec2(-0.105662f,-0.394338f), vec2(0.105662f,-0.105662f), vec2(0.394338f, 0.105662f), vec2(-0.394338f, 0.394338f), }, { vec2(-0.105662f,-0.105662f), vec2(0.105662f,-0.394338f), vec2(0.394338f, 0.394338f), vec2(-0.394338f, 0.105662f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Quad, 4, 9>[9][4] = { { vec2(-0.443649f,-0.443649f), vec2(0.443649f,-0.056351f), vec2(0.056351f, 0.056351f), vec2(-0.056351f, 0.443649f), }, { vec2(-0.443649f,-0.250000f), vec2(0.443649f,-0.250000f), vec2(0.056351f, 0.250000f), vec2(-0.056351f, 0.250000f), }, { vec2(-0.443649f,-0.056351f), vec2(0.443649f,-0.443649f), vec2(0.056351f, 0.443649f), vec2(-0.056351f, 0.056351f), }, { vec2(-0.250000f,-0.443649f), vec2(0.250000f,-0.056351f), vec2(0.250000f, 0.056351f), vec2(-0.250000f, 0.443649f), }, { vec2(-0.250000f,-0.250000f), vec2(0.250000f,-0.250000f), vec2(0.250000f, 0.250000f), vec2(-0.250000f, 0.250000f), }, { vec2(-0.250000f,-0.056351f), vec2(0.250000f,-0.443649f), vec2(0.250000f, 0.443649f), vec2(-0.250000f, 0.056351f), }, { vec2(-0.056351f,-0.443649f), vec2(0.056351f,-0.056351f), vec2(0.443649f, 0.056351f), vec2(-0.443649f, 0.443649f), }, { vec2(-0.056351f,-0.250000f), vec2(0.056351f,-0.250000f), vec2(0.443649f, 0.250000f), vec2(-0.443649f, 0.250000f), }, { vec2(-0.056351f,-0.056351f), vec2(0.056351f,-0.443649f), vec2(0.443649f, 0.443649f), vec2(-0.443649f, 0.056351f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Quad, 9, 1>[1][9] = { { vec2(0.000000f, 0.000000f), vec2(-0.000000f,-0.000000f), vec2(0.000000f, 0.000000f), vec2(-0.000000f,-0.000000f), vec2(0.000000f,-0.500000f), vec2(0.500000f,-0.000000f), vec2(-0.000000f, 0.500000f), vec2(-0.500000f, 0.000000f), vec2(-0.000000f,-0.000000f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Quad, 9, 4>[4][9] = { { vec2(-0.490562f,-0.490562f), vec2(-0.035221f, 0.131446f), vec2(0.009437f, 0.009437f), vec2(0.131446f,-0.035221f), vec2(0.525783f,-0.718234f), vec2(-0.051567f,-0.140883f), vec2(-0.140883f,-0.051567f), vec2(-0.718234f, 0.525783f), vec2(0.769800f, 0.769800f), }, { vec2(0.035221f, 0.131446f), vec2(0.490562f,-0.490562f), vec2(-0.131446f,-0.035221f), vec2(-0.009437f, 0.009437f), vec2(-0.525783f,-0.718234f), vec2(0.718234f, 0.525783f), vec2(0.140883f,-0.051567f), vec2(0.051567f,-0.140883f), vec2(-0.769800f, 0.769800f), }, { vec2(0.131446f, 0.035221f), vec2(0.009437f,-0.009437f), vec2(-0.035221f,-0.131446f), vec2(-0.490562f, 0.490562f), vec2(-0.140883f, 0.051567f), vec2(-0.051567f, 0.140883f), vec2(0.525783f, 0.718234f), vec2(-0.718234f,-0.525783f), vec2(0.769800f,-0.769800f), }, { vec2(-0.009437f,-0.009437f), vec2(-0.131446f, 0.035221f), vec2(0.490562f, 0.490562f), vec2(0.035221f,-0.131446f), vec2(0.140883f, 0.051567f), vec2(0.718234f,-0.525783f), vec2(-0.525783f, 0.718234f), vec2(0.051567f, 0.140883f), vec2(-0.769800f,-0.769800f), }, };
template<> constexpr vec2 ShapeFunctionGradients<FemShape::Quad, 9, 9>[9][9] = { { vec2(-0.876029f,-0.876029f), vec2(-0.188730f, 0.111270f), vec2(0.023972f, 0.023972f), vec2(0.111270f,-0.188730f), vec2(1.064759f,-0.509838f), vec2(-0.109839f,-0.135242f), vec2(-0.135242f,-0.109839f), vec2(-0.509838f, 1.064759f), vec2(0.619677f, 0.619677f), }, { vec2(-0.343649f, 0.000000f), vec2(0.343649f,-0.000000f), vec2(-0.043649f,-0.000000f), vec2(0.043649f, 0.000000f), vec2(-0.000000f,-1.274597f), vec2(0.200000f, 0.000000f), vec2(0.000000f,-0.274597f), vec2(-0.200000f,-0.000000f), vec2(-0.000000f, 1.549194f), }, { vec2(0.188730f, 0.111270f), vec2(0.876029f,-0.876029f), vec2(-0.111270f,-0.188730f), vec2(-0.023972f, 0.023972f), vec2(-1.064759f,-0.509838f), vec2(0.509838f, 1.064759f), vec2(0.135242f,-0.109839f), vec2(0.109839f,-0.135242f), vec2(-0.619677f, 0.619677f), }, { vec2(0.000000f,-0.343649f), vec2(0.000000f, 0.043649f), vec2(-0.000000f,-0.043649f), vec2(-0.000000f, 0.343649f), vec2(-0.000000f,-0.200000f), vec2(-0.274597f, 0.000000f), vec2(0.000000f, 0.200000f), vec2(-1.274597f,-0.000000f), vec2(1.549194f,-0.000000f), }, { vec2(0.000000f, 0.000000f), vec2(-0.000000f,-0.000000f), vec2(0.000000f, 0.000000f), vec2(-0.000000f,-0.000000f), vec2(0.000000f,-0.500000f), vec2(0.500000f,-0.000000f), vec2(-0.000000f, 0.500000f), vec2(-0.500000f, 0.000000f), vec2(-0.000000f,-0.000000f), }, { vec2(-0.000000f, 0.043649f), vec2(-0.000000f,-0.343649f), vec2(0.000000f, 0.343649f), vec2(0.000000f,-0.043649f), vec2(0.000000f,-0.200000f), vec2(1.274597f,-0.000000f), vec2(-0.000000f, 0.200000f), vec2(0.274597f, 0.000000f), vec2(-1.549194f,-0.000000f), }, { vec2(0.111270f, 0.188730f), vec2(0.023972f,-0.023972f), vec2(-0.188730f,-0.111270f), vec2(-0.876029f, 0.876029f), vec2(-0.135242f, 0.109839f), vec2(-0.109839f, 0.135242f), vec2(1.064759f, 0.509838f), vec2(-0.509838f,-1.064759f), vec2(0.619677f,-0.619677f), }, { vec2(0.043649f,-0.000000f), vec2(-0.043649f, 0.000000f), vec2(0.343649f, 0.000000f), vec2(-0.343649f,-0.000000f), vec2(0.000000f, 0.274597f), vec2(0.200000f,-0.000000f), vec2(-0.000000f, 1.274597f), vec2(-0.200000f, 0.000000f), vec2(-0.000000f,-1.549194f), }, { vec2(-0.023972f,-0.023972f), vec2(-0.111270f, 0.188730f), vec2(0.876029f, 0.876029f), vec2(0.188730f,-0.111270f), vec2(0.135242f, 0.109839f), vec2(0.509838f,-1.064759f), vec2(-1.064759f, 0.509838f), vec2(0.109839f, 0.135242f), vec2(-0.619677f,-0.619677f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Hex, 8, 1>[1][8] = { { vec3(-0.125000f,-0.125000f,-0.125000f), vec3(0.125000f,-0.125000f,-0.125000f), vec3(-0.125000f, 0.125000f,-0.125000f), vec3(0.125000f, 0.125000f,-0.125000f), vec3(-0.125000f,-0.125000f, 0.125000f), vec3(0.125000f,-0.125000f, 0.125000f), vec3(-0.125000f, 0.125000f, 0.125000f), vec3(0.125000f, 0.125000f, 0.125000f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Hex, 8, 8>[8][8] = { { vec3(-0.311004f,-0.311004f,-0.311004f), vec3(0.311004f,-0.083333f,-0.083333f), vec3(-0.083333f, 0.311004f,-0.083333f), vec3(0.083333f, 0.083333f,-0.022329f), vec3(-0.083333f,-0.083333f, 0.311004f), vec3(0.083333f,-0.022329f, 0.083333f), vec3(-0.022329f, 0.083333f, 0.083333f), vec3(0.022329f, 0.022329f, 0.022329f), }, { vec3(-0.311004f,-0.083333f,-0.083333f), vec3(0.311004f,-0.311004f,-0.311004f), vec3(-0.083333f, 0.083333f,-0.022329f), vec3(0.083333f, 0.311004f,-0.083333f), vec3(-0.083333f,-0.022329f, 0.083333f), vec3(0.083333f,-0.083333f, 0.311004f), vec3(-0.022329f, 0.022329f, 0.022329f), vec3(0.022329f, 0.083333f, 0.083333f), }, { vec3(-0.083333f,-0.311004f,-0.083333f), vec3(0.083333f,-0.083333f,-0.022329f), vec3(-0.311004f, 0.311004f,-0.311004f), vec3(0.311004f, 0.083333f,-0.083333f), vec3(-0.022329f,-0.083333f, 0.083333f), vec3(0.022329f,-0.022329f, 0.022329f), vec3(-0.083333f, 0.083333f, 0.311004f), vec3(0.083333f, 0.022329f, 0.083333f), }, { vec3(-0.083333f,-0.083333f,-0.022329f), vec3(0.083333f,-0.311004f,-0.083333f), vec3(-0.311004f, 0.083333f,-0.083333f), vec3(0.311004f, 0.311004f,-0.311004f), vec3(-0.022329f,-0.022329f, 0.022329f), vec3(0.022329f,-0.083333f, 0.083333f), vec3(-0.083333f, 0.022329f, 0.083333f), vec3(0.083333f, 0.083333f, 0.311004f), }, { vec3(-0.083333f,-0.083333f,-0.311004f), vec3(0.083333f,-0.022329f,-0.083333f), vec3(-0.022329f, 0.083333f,-0.083333f), vec3(0.022329f, 0.022329f,-0.022329f), vec3(-0.311004f,-0.311004f, 0.311004f), vec3(0.311004f,-0.083333f, 0.083333f), vec3(-0.083333f, 0.311004f, 0.083333f), vec3(0.083333f, 0.083333f, 0.022329f), }, { vec3(-0.083333f,-0.022329f,-0.083333f), vec3(0.083333f,-0.083333f,-0.311004f), vec3(-0.022329f, 0.022329f,-0.022329f), vec3(0.022329f, 0.083333f,-0.083333f), vec3(-0.311004f,-0.083333f, 0.083333f), vec3(0.311004f,-0.311004f, 0.311004f), vec3(-0.083333f, 0.083333f, 0.022329f), vec3(0.083333f, 0.311004f, 0.083333f), }, { vec3(-0.022329f,-0.083333f,-0.083333f), vec3(0.022329f,-0.022329f,-0.022329f), vec3(-0.083333f, 0.083333f,-0.311004f), vec3(0.083333f, 0.022329f,-0.083333f), vec3(-0.083333f,-0.311004f, 0.083333f), vec3(0.083333f,-0.083333f, 0.022329f), vec3(-0.311004f, 0.311004f, 0.311004f), vec3(0.311004f, 0.083333f, 0.083333f), }, { vec3(-0.022329f,-0.022329f,-0.022329f), vec3(0.022329f,-0.083333f,-0.083333f), vec3(-0.083333f, 0.022329f,-0.083333f), vec3(0.083333f, 0.083333f,-0.311004f), vec3(-0.083333f,-0.083333f, 0.022329f), vec3(0.083333f,-0.311004f, 0.083333f), vec3(-0.311004f, 0.083333f, 0.083333f), vec3(0.311004f, 0.311004f, 0.311004f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Hex, 8, 27>[27][8] = { { vec3(-0.393649f,-0.393649f,-0.393649f), vec3(0.393649f,-0.050000f,-0.050000f), vec3(-0.050000f, 0.393649f,-0.050000f), vec3(0.050000f, 0.050000f,-0.006351f), vec3(-0.050000f,-0.050000f, 0.393649f), vec3(0.050000f,-0.006351f, 0.050000f), vec3(-0.006351f, 0.050000f, 0.050000f), vec3(0.006351f, 0.006351f, 0.006351f), }, { vec3(-0.393649f,-0.221825f,-0.221825f), vec3(0.393649f,-0.221825f,-0.221825f), vec3(-0.050000f, 0.221825f,-0.028175f), vec3(0.050000f, 0.221825f,-0.028175f), vec3(-0.050000f,-0.028175f, 0.221825f), vec3(0.050000f,-0.028175f, 0.221825f), vec3(-0.006351f, 0.028175f, 0.028175f), vec3(0.006351f, 0.028175f, 0.028175f), }, { vec3(-0.393649f,-0.050000f,-0.050000f), vec3(0.393649f,-0.393649f,-0.393649f), vec3(-0.050000f, 0.050000f,-0.006351f), vec3(0.050000f, 0.393649f,-0.050000f), vec3(-0.050000f,-0.006351f, 0.050000f), vec3(0.050000f,-0.050000f, 0.393649f), vec3(-0.006351f, 0.006351f, 0.006351f), vec3(0.006351f, 0.050000f, 0.050000f), }, { vec3(-0.221825f,-0.393649f,-0.221825f), vec3(0.221825f,-0.050000f,-0.028175f), vec3(-0.221825f, 0.393649f,-0.221825f), vec3(0.221825f, 0.050000f,-0.028175f), vec3(-0.028175f,-0.050000f, 0.221825f), vec3(0.028175f,-0.006351f, 0.028175f), vec3(-0.028175f, 0.050000f, 0.221825f), vec3(0.028175f, 0.006351f, 0.028175f), }, { vec3(-0.221825f,-0.221825f,-0.125000f), vec3(0.221825f,-0.221825f,-0.125000f), vec3(-0.221825f, 0.221825f,-0.125000f), vec3(0.221825f, 0.221825f,-0.125000f), vec3(-0.028175f,-0.028175f, 0.125000f), vec3(0.028175f,-0.028175f, 0.125000f), vec3(-0.028175f, 0.028175f, 0.125000f), vec3(0.028175f, 0.028175f, 0.125000f), }, { vec3(-0.221825f,-0.050000f,-0.028175f), vec3(0.221825f,-0.393649f,-0.221825f), vec3(-0.221825f, 0.050000f,-0.028175f), vec3(0.221825f, 0.393649f,-0.221825f), vec3(-0.028175f,-0.006351f, 0.028175f), vec3(0.028175f,-0.050000f, 0.221825f), vec3(-0.028175f, 0.006351f, 0.028175f), vec3(0.028175f, 0.050000f, 0.221825f), }, { vec3(-0.050000f,-0.393649f,-0.050000f), vec3(0.050000f,-0.050000f,-0.006351f), vec3(-0.393649f, 0.393649f,-0.393649f), vec3(0.393649f, 0.050000f,-0.050000f), vec3(-0.006351f,-0.050000f, 0.050000f), vec3(0.006351f,-0.006351f, 0.006351f), vec3(-0.050000f, 0.050000f, 0.393649f), vec3(0.050000f, 0.006351f, 0.050000f), }, { vec3(-0.050000f,-0.221825f,-0.028175f), vec3(0.050000f,-0.221825f,-0.028175f), vec3(-0.393649f, 0.221825f,-0.221825f), vec3(0.393649f, 0.221825f,-0.221825f), vec3(-0.006351f,-0.028175f, 0.028175f), vec3(0.006351f,-0.028175f, 0.028175f), vec3(-0.050000f, 0.028175f, 0.221825f), vec3(0.050000f, 0.028175f, 0.221825f), }, { vec3(-0.050000f,-0.050000f,-0.006351f), vec3(0.050000f,-0.393649f,-0.050000f), vec3(-0.393649f, 0.050000f,-0.050000f), vec3(0.393649f, 0.393649f,-0.393649f), vec3(-0.006351f,-0.006351f, 0.006351f), vec3(0.006351f,-0.050000f, 0.050000f), vec3(-0.050000f, 0.006351f, 0.050000f), vec3(0.050000f, 0.050000f, 0.393649f), }, { vec3(-0.221825f,-0.221825f,-0.393649f), vec3(0.221825f,-0.028175f,-0.050000f), vec3(-0.028175f, 0.221825f,-0.050000f), vec3(0.028175f, 0.028175f,-0.006351f), vec3(-0.221825f,-0.221825f, 0.393649f), vec3(0.221825f,-0.028175f, 0.050000f), vec3(-0.028175f, 0.221825f, 0.050000f), vec3(0.028175f, 0.028175f, 0.006351f), }, { vec3(-0.221825f,-0.125000f,-0.221825f), vec3(0.221825f,-0.125000f,-0.221825f), vec3(-0.028175f, 0.125000f,-0.028175f), vec3(0.028175f, 0.125000f,-0.028175f), vec3(-0.221825f,-0.125000f, 0.221825f), vec3(0.221825f,-0.125000f, 0.221825f), vec3(-0.028175f, 0.125000f, 0.028175f), vec3(0.028175f, 0.125000f, 0.028175f), }, { vec3(-0.221825f,-0.028175f,-0.050000f), vec3(0.221825f,-0.221825f,-0.393649f), vec3(-0.028175f, 0.028175f,-0.006351f), vec3(0.028175f, 0.221825f,-0.050000f), vec3(-0.221825f,-0.028175f, 0.050000f), vec3(0.221825f,-0.221825f, 0.393649f), vec3(-0.028175f, 0.028175f, 0.006351f), vec3(0.028175f, 0.221825f, 0.050000f), }, { vec3(-0.125000f,-0.221825f,-0.221825f), vec3(0.125000f,-0.028175f,-0.028175f), vec3(-0.125000f, 0.221825f,-0.221825f), vec3(0.125000f, 0.028175f,-0.028175f), vec3(-0.125000f,-0.221825f, 0.221825f), vec3(0.125000f,-0.028175f, 0.028175f), vec3(-0.125000f, 0.221825f, 0.221825f), vec3(0.125000f, 0.028175f, 0.028175f), }, { vec3(-0.125000f,-0.125000f,-0.125000f), vec3(0.125000f,-0.125000f,-0.125000f), vec3(-0.125000f, 0.125000f,-0.125000f), vec3(0.125000f, 0.125000f,-0.125000f), vec3(-0.125000f,-0.125000f, 0.125000f), vec3(0.125000f,-0.125000f, 0.125000f), vec3(-0.125000f, 0.125000f, 0.125000f), vec3(0.125000f, 0.125000f, 0.125000f), }, { vec3(-0.125000f,-0.028175f,-0.028175f), vec3(0.125000f,-0.221825f,-0.221825f), vec3(-0.125000f, 0.028175f,-0.028175f), vec3(0.125000f, 0.221825f,-0.221825f), vec3(-0.125000f,-0.028175f, 0.028175f), vec3(0.125000f,-0.221825f, 0.221825f), vec3(-0.125000f, 0.028175f, 0.028175f), vec3(0.125000f, 0.221825f, 0.221825f), }, { vec3(-0.028175f,-0.221825f,-0.050000f), vec3(0.028175f,-0.028175f,-0.006351f), vec3(-0.221825f, 0.221825f,-0.393649f), vec3(0.221825f, 0.028175f,-0.050000f), vec3(-0.028175f,-0.221825f, 0.050000f), vec3(0.028175f,-0.028175f, 0.006351f), vec3(-0.221825f, 0.221825f, 0.393649f), vec3(0.221825f, 0.028175f, 0.050000f), }, { vec3(-0.028175f,-0.125000f,-0.028175f), vec3(0.028175f,-0.125000f,-0.028175f), vec3(-0.221825f, 0.125000f,-0.221825f), vec3(0.221825f, 0.125000f,-0.221825f), vec3(-0.028175f,-0.125000f, 0.028175f), vec3(0.028175f,-0.125000f, 0.028175f), vec3(-0.221825f, 0.125000f, 0.221825f), vec3(0.221825f, 0.125000f, 0.221825f), }, { vec3(-0.028175f,-0.028175f,-0.006351f), vec3(0.028175f,-0.221825f,-0.050000f), vec3(-0.221825f, 0.028175f,-0.050000f), vec3(0.221825f, 0.221825f,-0.393649f), vec3(-0.028175f,-0.028175f, 0.006351f), vec3(0.028175f,-0.221825f, 0.050000f), vec3(-0.221825f, 0.028175f, 0.050000f), vec3(0.221825f, 0.221825f, 0.393649f), }, { vec3(-0.050000f,-0.050000f,-0.393649f), vec3(0.050000f,-0.006351f,-0.050000f), vec3(-0.006351f, 0.050000f,-0.050000f), vec3(0.006351f, 0.006351f,-0.006351f), vec3(-0.393649f,-0.393649f, 0.393649f), vec3(0.393649f,-0.050000f, 0.050000f), vec3(-0.050000f, 0.393649f, 0.050000f), vec3(0.050000f, 0.050000f, 0.006351f), }, { vec3(-0.050000f,-0.028175f,-0.221825f), vec3(0.050000f,-0.028175f,-0.221825f), vec3(-0.006351f, 0.028175f,-0.028175f), vec3(0.006351f, 0.028175f,-0.028175f), vec3(-0.393649f,-0.221825f, 0.221825f), vec3(0.393649f,-0.221825f, 0.221825f), vec3(-0.050000f, 0.221825f, 0.028175f), vec3(0.050000f, 0.221825f, 0.028175f), }, { vec3(-0.050000f,-0.006351f,-0.050000f), vec3(0.050000f,-0.050000f,-0.393649f), vec3(-0.006351f, 0.006351f,-0.006351f), vec3(0.006351f, 0.050000f,-0.050000f), vec3(-0.393649f,-0.050000f, 0.050000f), vec3(0.393649f,-0.393649f, 0.393649f), vec3(-0.050000f, 0.050000f, 0.006351f), vec3(0.050000f, 0.393649f, 0.050000f), }, { vec3(-0.028175f,-0.050000f,-0.221825f), vec3(0.028175f,-0.006351f,-0.028175f), vec3(-0.028175f, 0.050000f,-0.221825f), vec3(0.028175f, 0.006351f,-0.028175f), vec3(-0.221825f,-0.393649f, 0.221825f), vec3(0.221825f,-0.050000f, 0.028175f), vec3(-0.221825f, 0.393649f, 0.221825f), vec3(0.221825f, 0.050000f, 0.028175f), }, { vec3(-0.028175f,-0.028175f,-0.125000f), vec3(0.028175f,-0.028175f,-0.125000f), vec3(-0.028175f, 0.028175f,-0.125000f), vec3(0.028175f, 0.028175f,-0.125000f), vec3(-0.221825f,-0.221825f, 0.125000f), vec3(0.221825f,-0.221825f, 0.125000f), vec3(-0.221825f, 0.221825f, 0.125000f), vec3(0.221825f, 0.221825f, 0.125000f), }, { vec3(-0.028175f,-0.006351f,-0.028175f), vec3(0.028175f,-0.050000f,-0.221825f), vec3(-0.028175f, 0.006351f,-0.028175f), vec3(0.028175f, 0.050000f,-0.221825f), vec3(-0.221825f,-0.050000f, 0.028175f), vec3(0.221825f,-0.393649f, 0.221825f), vec3(-0.221825f, 0.050000f, 0.028175f), vec3(0.221825f, 0.393649f, 0.221825f), }, { vec3(-0.006351f,-0.050000f,-0.050000f), vec3(0.006351f,-0.006351f,-0.006351f), vec3(-0.050000f, 0.050000f,-0.393649f), vec3(0.050000f, 0.006351f,-0.050000f), vec3(-0.050000f,-0.393649f, 0.050000f), vec3(0.050000f,-0.050000f, 0.006351f), vec3(-0.393649f, 0.393649f, 0.393649f), vec3(0.393649f, 0.050000f, 0.050000f), }, { vec3(-0.006351f,-0.028175f,-0.028175f), vec3(0.006351f,-0.028175f,-0.028175f), vec3(-0.050000f, 0.028175f,-0.221825f), vec3(0.050000f, 0.028175f,-0.221825f), vec3(-0.050000f,-0.221825f, 0.028175f), vec3(0.050000f,-0.221825f, 0.028175f), vec3(-0.393649f, 0.221825f, 0.221825f), vec3(0.393649f, 0.221825f, 0.221825f), }, { vec3(-0.006351f,-0.006351f,-0.006351f), vec3(0.006351f,-0.050000f,-0.050000f), vec3(-0.050000f, 0.006351f,-0.050000f), vec3(0.050000f, 0.050000f,-0.393649f), vec3(-0.050000f,-0.050000f, 0.006351f), vec3(0.050000f,-0.393649f, 0.050000f), vec3(-0.393649f, 0.050000f, 0.050000f), vec3(0.393649f, 0.393649f, 0.393649f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Hex, 27, 1>[1][27] = { { vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.500000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.500000f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.500000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.500000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.500000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.500000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Hex, 27, 8>[8][27] = { { vec3(-0.223373f,-0.223373f,-0.223373f), vec3(0.239411f,-0.327042f,-0.327042f), vec3(-0.016037f, 0.059853f, 0.059853f), vec3(-0.327042f, 0.239411f,-0.327042f), vec3(0.350522f, 0.350522f,-0.478823f), vec3(-0.023480f,-0.064150f, 0.087631f), vec3(0.059853f,-0.016037f, 0.059853f), vec3(-0.064150f,-0.023480f, 0.087631f), vec3(0.004297f, 0.004297f,-0.016038f), vec3(-0.327042f,-0.327042f, 0.239411f), vec3(0.350522f,-0.478823f, 0.350522f), vec3(-0.023480f, 0.087631f,-0.064150f), vec3(-0.478823f, 0.350522f, 0.350522f), vec3(0.513200f, 0.513200f, 0.513200f), vec3(-0.034378f,-0.093922f,-0.093922f), vec3(0.087631f,-0.023480f,-0.064150f), vec3(-0.093922f,-0.034378f,-0.093922f), vec3(0.006292f, 0.006292f, 0.017189f), vec3(0.059853f, 0.059853f,-0.016037f), vec3(-0.064150f, 0.087631f,-0.023480f), vec3(0.004297f,-0.016038f, 0.004297f), vec3(0.087631f,-0.064150f,-0.023480f), vec3(-0.093922f,-0.093922f,-0.034378f), vec3(0.006292f, 0.017189f, 0.006292f), vec3(-0.016038f, 0.004297f, 0.004297f), vec3(0.017189f, 0.006292f, 0.006292f), vec3(-0.001151f,-0.001151f,-0.001151f), }, { vec3(0.016037f, 0.059853f, 0.059853f), vec3(-0.239411f,-0.327042f,-0.327042f), vec3(0.223373f,-0.223373f,-0.223373f), vec3(0.023480f,-0.064150f, 0.087631f), vec3(-0.350522f, 0.350522f,-0.478823f), vec3(0.327042f, 0.239411f,-0.327042f), vec3(-0.004297f, 0.004297f,-0.016038f), vec3(0.064150f,-0.023480f, 0.087631f), vec3(-0.059853f,-0.016037f, 0.059853f), vec3(0.023480f, 0.087631f,-0.064150f), vec3(-0.350522f,-0.478823f, 0.350522f), vec3(0.327042f,-0.327042f, 0.239411f), vec3(0.034378f,-0.093922f,-0.093922f), vec3(-0.513200f, 0.513200f, 0.513200f), vec3(0.478823f, 0.350522f, 0.350522f), vec3(-0.006292f, 0.006292f, 0.017189f), vec3(0.093922f,-0.034378f,-0.093922f), vec3(-0.087631f,-0.023480f,-0.064150f), vec3(-0.004297f,-0.016038f, 0.004297f), vec3(0.064150f, 0.087631f,-0.023480f), vec3(-0.059853f, 0.059853f,-0.016037f), vec3(-0.006292f, 0.017189f, 0.006292f), vec3(0.093922f,-0.093922f,-0.034378f), vec3(-0.087631f,-0.064150f,-0.023480f), vec3(0.001151f,-0.001151f,-0.001151f), vec3(-0.017189f, 0.006292f, 0.006292f), vec3(0.016038f, 0.004297f, 0.004297f), }, { vec3(0.059853f, 0.016037f, 0.059853f), vec3(-0.064150f, 0.023480f, 0.087631f), vec3(0.004297f,-0.004297f,-0.016038f), vec3(-0.327042f,-0.239411f,-0.327042f), vec3(0.350522f,-0.350522f,-0.478823f), vec3(-0.023480f, 0.064150f, 0.087631f), vec3(-0.223373f, 0.223373f,-0.223373f), vec3(0.239411f, 0.327042f,-0.327042f), vec3(-0.016037f,-0.059853f, 0.059853f), vec3(0.087631f, 0.023480f,-0.064150f), vec3(-0.093922f, 0.034378f,-0.093922f), vec3(0.006292f,-0.006292f, 0.017189f), vec3(-0.478823f,-0.350522f, 0.350522f), vec3(0.513200f,-0.513200f, 0.513200f), vec3(-0.034378f, 0.093922f,-0.093922f), vec3(-0.327042f, 0.327042f, 0.239411f), vec3(0.350522f, 0.478823f, 0.350522f), vec3(-0.023480f,-0.087631f,-0.064150f), vec3(-0.016038f,-0.004297f, 0.004297f), vec3(0.017189f,-0.006292f, 0.006292f), vec3(-0.001151f, 0.001151f,-0.001151f), vec3(0.087631f, 0.064150f,-0.023480f), vec3(-0.093922f, 0.093922f,-0.034378f), vec3(0.006292f,-0.017189f, 0.006292f), vec3(0.059853f,-0.059853f,-0.016037f), vec3(-0.064150f,-0.087631f,-0.023480f), vec3(0.004297f, 0.016038f, 0.004297f), }, { vec3(-0.004297f,-0.004297f,-0.016038f), vec3(0.064150f, 0.023480f, 0.087631f), vec3(-0.059853f, 0.016037f, 0.059853f), vec3(0.023480f, 0.064150f, 0.087631f), vec3(-0.350522f,-0.350522f,-0.478823f), vec3(0.327042f,-0.239411f,-0.327042f), vec3(0.016037f,-0.059853f, 0.059853f), vec3(-0.239411f, 0.327042f,-0.327042f), vec3(0.223373f, 0.223373f,-0.223373f), vec3(-0.006292f,-0.006292f, 0.017189f), vec3(0.093922f, 0.034378f,-0.093922f), vec3(-0.087631f, 0.023480f,-0.064150f), vec3(0.034378f, 0.093922f,-0.093922f), vec3(-0.513200f,-0.513200f, 0.513200f), vec3(0.478823f,-0.350522f, 0.350522f), vec3(0.023480f,-0.087631f,-0.064150f), vec3(-0.350522f, 0.478823f, 0.350522f), vec3(0.327042f, 0.327042f, 0.239411f), vec3(0.001151f, 0.001151f,-0.001151f), vec3(-0.017189f,-0.006292f, 0.006292f), vec3(0.016038f,-0.004297f, 0.004297f), vec3(-0.006292f,-0.017189f, 0.006292f), vec3(0.093922f, 0.093922f,-0.034378f), vec3(-0.087631f, 0.064150f,-0.023480f), vec3(-0.004297f, 0.016038f, 0.004297f), vec3(0.064150f,-0.087631f,-0.023480f), vec3(-0.059853f,-0.059853f,-0.016037f), }, { vec3(0.059853f, 0.059853f, 0.016037f), vec3(-0.064150f, 0.087631f, 0.023480f), vec3(0.004297f,-0.016038f,-0.004297f), vec3(0.087631f,-0.064150f, 0.023480f), vec3(-0.093922f,-0.093922f, 0.034378f), vec3(0.006292f, 0.017189f,-0.006292f), vec3(-0.016038f, 0.004297f,-0.004297f), vec3(0.017189f, 0.006292f,-0.006292f), vec3(-0.001151f,-0.001151f, 0.001151f), vec3(-0.327042f,-0.327042f,-0.239411f), vec3(0.350522f,-0.478823f,-0.350522f), vec3(-0.023480f, 0.087631f, 0.064150f), vec3(-0.478823f, 0.350522f,-0.350522f), vec3(0.513200f, 0.513200f,-0.513200f), vec3(-0.034378f,-0.093922f, 0.093922f), vec3(0.087631f,-0.023480f, 0.064150f), vec3(-0.093922f,-0.034378f, 0.093922f), vec3(0.006292f, 0.006292f,-0.017189f), vec3(-0.223373f,-0.223373f, 0.223373f), vec3(0.239411f,-0.327042f, 0.327042f), vec3(-0.016037f, 0.059853f,-0.059853f), vec3(-0.327042f, 0.239411f, 0.327042f), vec3(0.350522f, 0.350522f, 0.478823f), vec3(-0.023480f,-0.064150f,-0.087631f), vec3(0.059853f,-0.016037f,-0.059853f), vec3(-0.064150f,-0.023480f,-0.087631f), vec3(0.004297f, 0.004297f, 0.016038f), }, { vec3(-0.004297f,-0.016038f,-0.004297f), vec3(0.064150f, 0.087631f, 0.023480f), vec3(-0.059853f, 0.059853f, 0.016037f), vec3(-0.006292f, 0.017189f,-0.006292f), vec3(0.093922f,-0.093922f, 0.034378f), vec3(-0.087631f,-0.064150f, 0.023480f), vec3(0.001151f,-0.001151f, 0.001151f), vec3(-0.017189f, 0.006292f,-0.006292f), vec3(0.016038f, 0.004297f,-0.004297f), vec3(0.023480f, 0.087631f, 0.064150f), vec3(-0.350522f,-0.478823f,-0.350522f), vec3(0.327042f,-0.327042f,-0.239411f), vec3(0.034378f,-0.093922f, 0.093922f), vec3(-0.513200f, 0.513200f,-0.513200f), vec3(0.478823f, 0.350522f,-0.350522f), vec3(-0.006292f, 0.006292f,-0.017189f), vec3(0.093922f,-0.034378f, 0.093922f), vec3(-0.087631f,-0.023480f, 0.064150f), vec3(0.016037f, 0.059853f,-0.059853f), vec3(-0.239411f,-0.327042f, 0.327042f), vec3(0.223373f,-0.223373f, 0.223373f), vec3(0.023480f,-0.064150f,-0.087631f), vec3(-0.350522f, 0.350522f, 0.478823f), vec3(0.327042f, 0.239411f, 0.327042f), vec3(-0.004297f, 0.004297f, 0.016038f), vec3(0.064150f,-0.023480f,-0.087631f), vec3(-0.059853f,-0.016037f,-0.059853f), }, { vec3(-0.016038f,-0.004297f,-0.004297f), vec3(0.017189f,-0.006292f,-0.006292f), vec3(-0.001151f, 0.001151f, 0.001151f), vec3(0.087631f, 0.064150f, 0.023480f), vec3(-0.093922f, 0.093922f, 0.034378f), vec3(0.006292f,-0.017189f,-0.006292f), vec3(0.059853f,-0.059853f, 0.016037f), vec3(-0.064150f,-0.087631f, 0.023480f), vec3(0.004297f, 0.016038f,-0.004297f), vec3(0.087631f, 0.023480f, 0.064150f), vec3(-0.093922f, 0.034378f, 0.093922f), vec3(0.006292f,-0.006292f,-0.017189f), vec3(-0.478823f,-0.350522f,-0.350522f), vec3(0.513200f,-0.513200f,-0.513200f), vec3(-0.034378f, 0.093922f, 0.093922f), vec3(-0.327042f, 0.327042f,-0.239411f), vec3(0.350522f, 0.478823f,-0.350522f), vec3(-0.023480f,-0.087631f, 0.064150f), vec3(0.059853f, 0.016037f,-0.059853f), vec3(-0.064150f, 0.023480f,-0.087631f), vec3(0.004297f,-0.004297f, 0.016038f), vec3(-0.327042f,-0.239411f, 0.327042f), vec3(0.350522f,-0.350522f, 0.478823f), vec3(-0.023480f, 0.064150f,-0.087631f), vec3(-0.223373f, 0.223373f, 0.223373f), vec3(0.239411f, 0.327042f, 0.327042f), vec3(-0.016037f,-0.059853f,-0.059853f), }, { vec3(0.001151f, 0.001151f, 0.001151f), vec3(-0.017189f,-0.006292f,-0.006292f), vec3(0.016038f,-0.004297f,-0.004297f), vec3(-0.006292f,-0.017189f,-0.006292f), vec3(0.093922f, 0.093922f, 0.034378f), vec3(-0.087631f, 0.064150f, 0.023480f), vec3(-0.004297f, 0.016038f,-0.004297f), vec3(0.064150f,-0.087631f, 0.023480f), vec3(-0.059853f,-0.059853f, 0.016037f), vec3(-0.006292f,-0.006292f,-0.017189f), vec3(0.093922f, 0.034378f, 0.093922f), vec3(-0.087631f, 0.023480f, 0.064150f), vec3(0.034378f, 0.093922f, 0.093922f), vec3(-0.513200f,-0.513200f,-0.513200f), vec3(0.478823f,-0.350522f,-0.350522f), vec3(0.023480f,-0.087631f, 0.064150f), vec3(-0.350522f, 0.478823f,-0.350522f), vec3(0.327042f, 0.327042f,-0.239411f), vec3(-0.004297f,-0.004297f, 0.016038f), vec3(0.064150f, 0.023480f,-0.087631f), vec3(-0.059853f, 0.016037f,-0.059853f), vec3(0.023480f, 0.064150f,-0.087631f), vec3(-0.350522f,-0.350522f, 0.478823f), vec3(0.327042f,-0.239411f, 0.327042f), vec3(0.016037f,-0.059853f,-0.059853f), vec3(-0.239411f, 0.327042f, 0.327042f), vec3(0.223373f, 0.223373f, 0.223373f), }, };
template<> constexpr vec3 ShapeFunctionGradients<FemShape::Hex, 27, 27>[27][27] = {
	{ vec3(-0.602094f,-0.602094f,-0.602094f), vec3(0.731808f,-0.350411f,-0.350411f), vec3(-0.129714f, 0.076476f, 0.076476f), vec3(-0.350411f, 0.731808f,-0.350411f), vec3(0.425903f, 0.425903f,-0.203935f), vec3(-0.075492f,-0.092952f, 0.044508f), vec3(0.076476f,-0.129714f, 0.076476f), vec3(-0.092952f,-0.075492f, 0.044508f), vec3(0.016476f, 0.016476f,-0.009714f), vec3(-0.350411f,-0.350411f, 0.731808f), vec3(0.425903f,-0.203935f, 0.425903f), vec3(-0.075492f, 0.044508f,-0.092952f), vec3(-0.203935f, 0.425903f, 0.425903f), vec3(0.247870f, 0.247870f, 0.247870f), vec3(-0.043935f,-0.054097f,-0.054097f), vec3(0.044508f,-0.075492f,-0.092952f), vec3(-0.054097f,-0.043935f,-0.054097f), vec3(0.009589f, 0.009589f, 0.011806f), vec3(0.076476f, 0.076476f,-0.129714f), vec3(-0.092952f, 0.044508f,-0.075492f), vec3(0.016476f,-0.009714f, 0.016476f), vec3(0.044508f,-0.092952f,-0.075492f), vec3(-0.054097f,-0.054097f,-0.043935f), vec3(0.009589f, 0.011806f, 0.009589f), vec3(-0.009714f, 0.016476f, 0.016476f), vec3(0.011806f, 0.009589f, 0.009589f), vec3(-0.002093f,-0.002093f,-0.002093f), }, { vec3(-0.236190f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.876029f,-0.876029f), vec3(0.236190f,-0.000000f,-0.000000f), vec3(-0.137460f,-0.000000f, 0.000000f), vec3(-0.000000f, 1.064759f,-0.509838f), vec3(0.137460f, 0.000000f,-0.000000f), vec3(0.030000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.188730f, 0.111270f), vec3(-0.030000f,-0.000000f, 0.000000f), vec3(-0.137460f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.509838f, 1.064759f), vec3(0.137460f,-0.000000f, 0.000000f), vec3(-0.080000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.619677f, 0.619677f), vec3(0.080000f, 0.000000f, 0.000000f), vec3(0.017460f, 0.000000f, 0.000000f), vec3(0.000000f,-0.109839f,-0.135242f), vec3(-0.017460f,-0.000000f,-0.000000f), vec3(0.030000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.111270f,-0.188730f), vec3(-0.030000f, 0.000000f,-0.000000f), vec3(0.017460f, 0.000000f, 0.000000f), vec3(0.000000f,-0.135242f,-0.109839f), vec3(-0.017460f,-0.000000f,-0.000000f), vec3(-0.003810f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.023972f, 0.023972f), vec3(0.003810f, 0.000000f, 0.000000f), }, { vec3(0.129714f, 0.076476f, 0.076476f), vec3(-0.731808f,-0.350411f,-0.350411f), vec3(0.602094f,-0.602094f,-0.602094f), vec3(0.075492f,-0.092952f, 0.044508f), vec3(-0.425903f, 0.425903f,-0.203935f), vec3(0.350411f, 0.731808f,-0.350411f), vec3(-0.016476f, 0.016476f,-0.009714f), vec3(0.092952f,-0.075492f, 0.044508f), vec3(-0.076476f,-0.129714f, 0.076476f), vec3(0.075492f, 0.044508f,-0.092952f), vec3(-0.425903f,-0.203935f, 0.425903f), vec3(0.350411f,-0.350411f, 0.731808f), vec3(0.043935f,-0.054097f,-0.054097f), vec3(-0.247870f, 0.247870f, 0.247870f), vec3(0.203935f, 0.425903f, 0.425903f), vec3(-0.009589f, 0.009589f, 0.011806f), vec3(0.054097f,-0.043935f,-0.054097f), vec3(-0.044508f,-0.075492f,-0.092952f), vec3(-0.016476f,-0.009714f, 0.016476f), vec3(0.092952f, 0.044508f,-0.075492f), vec3(-0.076476f, 0.076476f,-0.129714f), vec3(-0.009589f, 0.011806f, 0.009589f), vec3(0.054097f,-0.054097f,-0.043935f), vec3(-0.044508f,-0.092952f,-0.075492f), vec3(0.002093f,-0.002093f,-0.002093f), vec3(-0.011806f, 0.009589f, 0.009589f), vec3(0.009714f, 0.016476f, 0.016476f), }, { vec3(0.000000f,-0.236190f, 0.000000f), vec3(-0.000000f,-0.137460f, 0.000000f), vec3(0.000000f, 0.030000f,-0.000000f), vec3(-0.876029f,-0.000000f,-0.876029f), vec3(1.064759f,-0.000000f,-0.509838f), vec3(-0.188730f, 0.000000f, 0.111270f), vec3(-0.000000f, 0.236190f,-0.000000f), vec3(0.000000f, 0.137460f,-0.000000f), vec3(-0.000000f,-0.030000f, 0.000000f), vec3(0.000000f,-0.137460f,-0.000000f), vec3(-0.000000f,-0.080000f,-0.000000f), vec3(0.000000f, 0.017460f, 0.000000f), vec3(-0.509838f,-0.000000f, 1.064759f), vec3(0.619677f,-0.000000f, 0.619677f), vec3(-0.109839f, 0.000000f,-0.135242f), vec3(-0.000000f, 0.137460f, 0.000000f), vec3(0.000000f, 0.080000f, 0.000000f), vec3(-0.000000f,-0.017460f,-0.000000f), vec3(-0.000000f, 0.030000f, 0.000000f), vec3(0.000000f, 0.017460f, 0.000000f), vec3(-0.000000f,-0.003810f,-0.000000f), vec3(0.111270f, 0.000000f,-0.188730f), vec3(-0.135242f, 0.000000f,-0.109839f), vec3(0.023972f,-0.000000f, 0.023972f), vec3(0.000000f,-0.030000f,-0.000000f), vec3(-0.000000f,-0.017460f,-0.000000f), vec3(0.000000f, 0.003810f, 0.000000f), }, { vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.343649f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.343649f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-1.274597f), vec3(0.343649f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.343649f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.200000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.200000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 1.549194f), vec3(0.200000f,-0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.200000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.043649f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.043649f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.274597f), vec3(-0.043649f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.043649f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), }, { vec3(-0.000000f, 0.030000f,-0.000000f), vec3(0.000000f,-0.137460f, 0.000000f), vec3(-0.000000f,-0.236190f, 0.000000f), vec3(0.188730f, 0.000000f, 0.111270f), vec3(-1.064759f,-0.000000f,-0.509838f), vec3(0.876029f,-0.000000f,-0.876029f), vec3(0.000000f,-0.030000f, 0.000000f), vec3(-0.000000f, 0.137460f,-0.000000f), vec3(0.000000f, 0.236190f,-0.000000f), vec3(-0.000000f, 0.017460f, 0.000000f), vec3(0.000000f,-0.080000f,-0.000000f), vec3(-0.000000f,-0.137460f,-0.000000f), vec3(0.109839f, 0.000000f,-0.135242f), vec3(-0.619677f,-0.000000f, 0.619677f), vec3(0.509838f,-0.000000f, 1.064759f), vec3(0.000000f,-0.017460f,-0.000000f), vec3(-0.000000f, 0.080000f, 0.000000f), vec3(0.000000f, 0.137460f, 0.000000f), vec3(0.000000f,-0.003810f,-0.000000f), vec3(-0.000000f, 0.017460f, 0.000000f), vec3(0.000000f, 0.030000f, 0.000000f), vec3(-0.023972f,-0.000000f, 0.023972f), vec3(0.135242f, 0.000000f,-0.109839f), vec3(-0.111270f, 0.000000f,-0.188730f), vec3(-0.000000f, 0.003810f, 0.000000f), vec3(0.000000f,-0.017460f,-0.000000f), vec3(-0.000000f,-0.030000f,-0.000000f), }, { vec3(0.076476f, 0.129714f, 0.076476f), vec3(-0.092952f, 0.075492f, 0.044508f), vec3(0.016476f,-0.016476f,-0.009714f), vec3(-0.350411f,-0.731808f,-0.350411f), vec3(0.425903f,-0.425903f,-0.203935f), vec3(-0.075492f, 0.092952f, 0.044508f), vec3(-0.602094f, 0.602094f,-0.602094f), vec3(0.731808f, 0.350411f,-0.350411f), vec3(-0.129714f,-0.076476f, 0.076476f), vec3(0.044508f, 0.075492f,-0.092952f), vec3(-0.054097f, 0.043935f,-0.054097f), vec3(0.009589f,-0.009589f, 0.011806f), vec3(-0.203935f,-0.425903f, 0.425903f), vec3(0.247870f,-0.247870f, 0.247870f), vec3(-0.043935f, 0.054097f,-0.054097f), vec3(-0.350411f, 0.350411f, 0.731808f), vec3(0.425903f, 0.203935f, 0.425903f), vec3(-0.075492f,-0.044508f,-0.092952f), vec3(-0.009714f,-0.016476f, 0.016476f), vec3(0.011806f,-0.009589f, 0.009589f), vec3(-0.002093f, 0.002093f,-0.002093f), vec3(0.044508f, 0.092952f,-0.075492f), vec3(-0.054097f, 0.054097f,-0.043935f), vec3(0.009589f,-0.011806f, 0.009589f), vec3(0.076476f,-0.076476f,-0.129714f), vec3(-0.092952f,-0.044508f,-0.075492f), vec3(0.016476f, 0.009714f, 0.016476f), }, { vec3(0.030000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.188730f, 0.111270f), vec3(-0.030000f, 0.000000f, 0.000000f), vec3(-0.137460f, 0.000000f, 0.000000f), vec3(-0.000000f,-1.064759f,-0.509838f), vec3(0.137460f,-0.000000f,-0.000000f), vec3(-0.236190f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.876029f,-0.876029f), vec3(0.236190f, 0.000000f,-0.000000f), vec3(0.017460f,-0.000000f, 0.000000f), vec3(0.000000f, 0.109839f,-0.135242f), vec3(-0.017460f, 0.000000f,-0.000000f), vec3(-0.080000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.619677f, 0.619677f), vec3(0.080000f,-0.000000f, 0.000000f), vec3(-0.137460f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.509838f, 1.064759f), vec3(0.137460f, 0.000000f, 0.000000f), vec3(-0.003810f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.023972f, 0.023972f), vec3(0.003810f,-0.000000f, 0.000000f), vec3(0.017460f,-0.000000f, 0.000000f), vec3(0.000000f, 0.135242f,-0.109839f), vec3(-0.017460f, 0.000000f,-0.000000f), vec3(0.030000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.111270f,-0.188730f), vec3(-0.030000f,-0.000000f,-0.000000f), }, { vec3(-0.016476f,-0.016476f,-0.009714f), vec3(0.092952f, 0.075492f, 0.044508f), vec3(-0.076476f, 0.129714f, 0.076476f), vec3(0.075492f, 0.092952f, 0.044508f), vec3(-0.425903f,-0.425903f,-0.203935f), vec3(0.350411f,-0.731808f,-0.350411f), vec3(0.129714f,-0.076476f, 0.076476f), vec3(-0.731808f, 0.350411f,-0.350411f), vec3(0.602094f, 0.602094f,-0.602094f), vec3(-0.009589f,-0.009589f, 0.011806f), vec3(0.054097f, 0.043935f,-0.054097f), vec3(-0.044508f, 0.075492f,-0.092952f), vec3(0.043935f, 0.054097f,-0.054097f), vec3(-0.247870f,-0.247870f, 0.247870f), vec3(0.203935f,-0.425903f, 0.425903f), vec3(0.075492f,-0.044508f,-0.092952f), vec3(-0.425903f, 0.203935f, 0.425903f), vec3(0.350411f, 0.350411f, 0.731808f), vec3(0.002093f, 0.002093f,-0.002093f), vec3(-0.011806f,-0.009589f, 0.009589f), vec3(0.009714f,-0.016476f, 0.016476f), vec3(-0.009589f,-0.011806f, 0.009589f), vec3(0.054097f, 0.054097f,-0.043935f), vec3(-0.044508f, 0.092952f,-0.075492f), vec3(-0.016476f, 0.009714f, 0.016476f), vec3(0.092952f,-0.044508f,-0.075492f), vec3(-0.076476f,-0.076476f,-0.129714f), },
	{ vec3(0.000000f, 0.000000f,-0.236190f), vec3(-0.000000f, 0.000000f,-0.137460f), vec3(0.000000f,-0.000000f, 0.030000f), vec3(0.000000f,-0.000000f,-0.137460f), vec3(-0.000000f,-0.000000f,-0.080000f), vec3(0.000000f, 0.000000f, 0.017460f), vec3(-0.000000f, 0.000000f, 0.030000f), vec3(0.000000f, 0.000000f, 0.017460f), vec3(-0.000000f,-0.000000f,-0.003810f), vec3(-0.876029f,-0.876029f,-0.000000f), vec3(1.064759f,-0.509838f,-0.000000f), vec3(-0.188730f, 0.111270f, 0.000000f), vec3(-0.509838f, 1.064759f,-0.000000f), vec3(0.619677f, 0.619677f,-0.000000f), vec3(-0.109839f,-0.135242f, 0.000000f), vec3(0.111270f,-0.188730f, 0.000000f), vec3(-0.135242f,-0.109839f, 0.000000f), vec3(0.023972f, 0.023972f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.236190f), vec3(0.000000f,-0.000000f, 0.137460f), vec3(-0.000000f, 0.000000f,-0.030000f), vec3(-0.000000f, 0.000000f, 0.137460f), vec3(0.000000f, 0.000000f, 0.080000f), vec3(-0.000000f,-0.000000f,-0.017460f), vec3(0.000000f,-0.000000f,-0.030000f), vec3(-0.000000f,-0.000000f,-0.017460f), vec3(0.000000f, 0.000000f, 0.003810f), }, { vec3(0.000000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.343649f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.200000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.043649f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.343649f, 0.000000f, 0.000000f), vec3(-0.000000f,-1.274597f,-0.000000f), vec3(0.343649f,-0.000000f,-0.000000f), vec3(-0.200000f,-0.000000f, 0.000000f), vec3(-0.000000f, 1.549194f,-0.000000f), vec3(0.200000f, 0.000000f,-0.000000f), vec3(0.043649f, 0.000000f,-0.000000f), vec3(0.000000f,-0.274597f, 0.000000f), vec3(-0.043649f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.343649f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.200000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.043649f), vec3(-0.000000f,-0.000000f,-0.000000f), }, { vec3(-0.000000f,-0.000000f, 0.030000f), vec3(0.000000f, 0.000000f,-0.137460f), vec3(-0.000000f, 0.000000f,-0.236190f), vec3(-0.000000f, 0.000000f, 0.017460f), vec3(0.000000f,-0.000000f,-0.080000f), vec3(-0.000000f,-0.000000f,-0.137460f), vec3(0.000000f,-0.000000f,-0.003810f), vec3(-0.000000f, 0.000000f, 0.017460f), vec3(0.000000f, 0.000000f, 0.030000f), vec3(0.188730f, 0.111270f, 0.000000f), vec3(-1.064759f,-0.509838f,-0.000000f), vec3(0.876029f,-0.876029f,-0.000000f), vec3(0.109839f,-0.135242f, 0.000000f), vec3(-0.619677f, 0.619677f,-0.000000f), vec3(0.509838f, 1.064759f,-0.000000f), vec3(-0.023972f, 0.023972f,-0.000000f), vec3(0.135242f,-0.109839f, 0.000000f), vec3(-0.111270f,-0.188730f, 0.000000f), vec3(0.000000f, 0.000000f,-0.030000f), vec3(-0.000000f,-0.000000f, 0.137460f), vec3(0.000000f,-0.000000f, 0.236190f), vec3(0.000000f,-0.000000f,-0.017460f), vec3(-0.000000f, 0.000000f, 0.080000f), vec3(0.000000f, 0.000000f, 0.137460f), vec3(-0.000000f, 0.000000f, 0.003810f), vec3(0.000000f,-0.000000f,-0.017460f), vec3(-0.000000f,-0.000000f,-0.030000f), }, { vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.343649f), vec3(-0.000000f, 0.000000f,-0.200000f), vec3(0.000000f,-0.000000f, 0.043649f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.343649f, 0.000000f), vec3(-0.000000f,-0.200000f, 0.000000f), vec3(0.000000f, 0.043649f,-0.000000f), vec3(-1.274597f,-0.000000f,-0.000000f), vec3(1.549194f,-0.000000f,-0.000000f), vec3(-0.274597f, 0.000000f, 0.000000f), vec3(-0.000000f, 0.343649f,-0.000000f), vec3(0.000000f, 0.200000f,-0.000000f), vec3(-0.000000f,-0.043649f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.343649f), vec3(0.000000f,-0.000000f, 0.200000f), vec3(-0.000000f, 0.000000f,-0.043649f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), }, { vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.500000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.500000f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.500000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.500000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.500000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.500000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), }, { vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.043649f), vec3(0.000000f, 0.000000f,-0.200000f), vec3(-0.000000f, 0.000000f,-0.343649f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.043649f,-0.000000f), vec3(0.000000f,-0.200000f, 0.000000f), vec3(-0.000000f,-0.343649f, 0.000000f), vec3(0.274597f, 0.000000f, 0.000000f), vec3(-1.549194f,-0.000000f,-0.000000f), vec3(1.274597f,-0.000000f,-0.000000f), vec3(0.000000f,-0.043649f, 0.000000f), vec3(-0.000000f, 0.200000f,-0.000000f), vec3(0.000000f, 0.343649f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.043649f), vec3(-0.000000f,-0.000000f, 0.200000f), vec3(0.000000f,-0.000000f, 0.343649f), vec3(0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), }, { vec3(-0.000000f,-0.000000f, 0.030000f), vec3(0.000000f,-0.000000f, 0.017460f), vec3(-0.000000f, 0.000000f,-0.003810f), vec3(0.000000f, 0.000000f,-0.137460f), vec3(-0.000000f, 0.000000f,-0.080000f), vec3(0.000000f,-0.000000f, 0.017460f), vec3(0.000000f,-0.000000f,-0.236190f), vec3(-0.000000f,-0.000000f,-0.137460f), vec3(0.000000f, 0.000000f, 0.030000f), vec3(0.111270f, 0.188730f, 0.000000f), vec3(-0.135242f, 0.109839f, 0.000000f), vec3(0.023972f,-0.023972f,-0.000000f), vec3(-0.509838f,-1.064759f,-0.000000f), vec3(0.619677f,-0.619677f,-0.000000f), vec3(-0.109839f, 0.135242f, 0.000000f), vec3(-0.876029f, 0.876029f,-0.000000f), vec3(1.064759f, 0.509838f,-0.000000f), vec3(-0.188730f,-0.111270f, 0.000000f), vec3(0.000000f, 0.000000f,-0.030000f), vec3(-0.000000f, 0.000000f,-0.017460f), vec3(0.000000f,-0.000000f, 0.003810f), vec3(-0.000000f,-0.000000f, 0.137460f), vec3(0.000000f,-0.000000f, 0.080000f), vec3(-0.000000f, 0.000000f,-0.017460f), vec3(-0.000000f, 0.000000f, 0.236190f), vec3(0.000000f, 0.000000f, 0.137460f), vec3(-0.000000f,-0.000000f,-0.030000f), }, { vec3(-0.000000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.043649f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.200000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.000000f,-0.343649f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(0.043649f,-0.000000f,-0.000000f), vec3(0.000000f, 0.274597f, 0.000000f), vec3(-0.043649f, 0.000000f, 0.000000f), vec3(-0.200000f, 0.000000f, 0.000000f), vec3(-0.000000f,-1.549194f,-0.000000f), vec3(0.200000f,-0.000000f,-0.000000f), vec3(-0.343649f,-0.000000f, 0.000000f), vec3(-0.000000f, 1.274597f,-0.000000f), vec3(0.343649f, 0.000000f,-0.000000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.043649f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.200000f), vec3(0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.000000f, 0.343649f), vec3(0.000000f, 0.000000f, 0.000000f), }, { vec3(0.000000f, 0.000000f,-0.003810f), vec3(-0.000000f,-0.000000f, 0.017460f), vec3(0.000000f,-0.000000f, 0.030000f), vec3(-0.000000f,-0.000000f, 0.017460f), vec3(0.000000f, 0.000000f,-0.080000f), vec3(-0.000000f, 0.000000f,-0.137460f), vec3(-0.000000f, 0.000000f, 0.030000f), vec3(0.000000f,-0.000000f,-0.137460f), vec3(-0.000000f,-0.000000f,-0.236190f), vec3(-0.023972f,-0.023972f,-0.000000f), vec3(0.135242f, 0.109839f, 0.000000f), vec3(-0.111270f, 0.188730f, 0.000000f), vec3(0.109839f, 0.135242f, 0.000000f), vec3(-0.619677f,-0.619677f,-0.000000f), vec3(0.509838f,-1.064759f,-0.000000f), vec3(0.188730f,-0.111270f, 0.000000f), vec3(-1.064759f, 0.509838f,-0.000000f), vec3(0.876029f, 0.876029f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.003810f), vec3(0.000000f, 0.000000f,-0.017460f), vec3(-0.000000f, 0.000000f,-0.030000f), vec3(0.000000f, 0.000000f,-0.017460f), vec3(-0.000000f,-0.000000f, 0.080000f), vec3(0.000000f,-0.000000f, 0.137460f), vec3(0.000000f,-0.000000f,-0.030000f), vec3(-0.000000f, 0.000000f, 0.137460f), vec3(0.000000f, 0.000000f, 0.236190f), },
	{ vec3(0.076476f, 0.076476f, 0.129714f), vec3(-0.092952f, 0.044508f, 0.075492f), vec3(0.016476f,-0.009714f,-0.016476f), vec3(0.044508f,-0.092952f, 0.075492f), vec3(-0.054097f,-0.054097f, 0.043935f), vec3(0.009589f, 0.011806f,-0.009589f), vec3(-0.009714f, 0.016476f,-0.016476f), vec3(0.011806f, 0.009589f,-0.009589f), vec3(-0.002093f,-0.002093f, 0.002093f), vec3(-0.350411f,-0.350411f,-0.731808f), vec3(0.425903f,-0.203935f,-0.425903f), vec3(-0.075492f, 0.044508f, 0.092952f), vec3(-0.203935f, 0.425903f,-0.425903f), vec3(0.247870f, 0.247870f,-0.247870f), vec3(-0.043935f,-0.054097f, 0.054097f), vec3(0.044508f,-0.075492f, 0.092952f), vec3(-0.054097f,-0.043935f, 0.054097f), vec3(0.009589f, 0.009589f,-0.011806f), vec3(-0.602094f,-0.602094f, 0.602094f), vec3(0.731808f,-0.350411f, 0.350411f), vec3(-0.129714f, 0.076476f,-0.076476f), vec3(-0.350411f, 0.731808f, 0.350411f), vec3(0.425903f, 0.425903f, 0.203935f), vec3(-0.075492f,-0.092952f,-0.044508f), vec3(0.076476f,-0.129714f,-0.076476f), vec3(-0.092952f,-0.075492f,-0.044508f), vec3(0.016476f, 0.016476f, 0.009714f), }, { vec3(0.030000f,-0.000000f,-0.000000f), vec3(0.000000f, 0.111270f, 0.188730f), vec3(-0.030000f, 0.000000f, 0.000000f), vec3(0.017460f, 0.000000f,-0.000000f), vec3(0.000000f,-0.135242f, 0.109839f), vec3(-0.017460f,-0.000000f, 0.000000f), vec3(-0.003810f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.023972f,-0.023972f), vec3(0.003810f, 0.000000f,-0.000000f), vec3(-0.137460f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.509838f,-1.064759f), vec3(0.137460f,-0.000000f,-0.000000f), vec3(-0.080000f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.619677f,-0.619677f), vec3(0.080000f, 0.000000f,-0.000000f), vec3(0.017460f, 0.000000f,-0.000000f), vec3(0.000000f,-0.109839f, 0.135242f), vec3(-0.017460f,-0.000000f, 0.000000f), vec3(-0.236190f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.876029f, 0.876029f), vec3(0.236190f,-0.000000f, 0.000000f), vec3(-0.137460f,-0.000000f,-0.000000f), vec3(-0.000000f, 1.064759f, 0.509838f), vec3(0.137460f, 0.000000f, 0.000000f), vec3(0.030000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.188730f,-0.111270f), vec3(-0.030000f,-0.000000f,-0.000000f), }, { vec3(-0.016476f,-0.009714f,-0.016476f), vec3(0.092952f, 0.044508f, 0.075492f), vec3(-0.076476f, 0.076476f, 0.129714f), vec3(-0.009589f, 0.011806f,-0.009589f), vec3(0.054097f,-0.054097f, 0.043935f), vec3(-0.044508f,-0.092952f, 0.075492f), vec3(0.002093f,-0.002093f, 0.002093f), vec3(-0.011806f, 0.009589f,-0.009589f), vec3(0.009714f, 0.016476f,-0.016476f), vec3(0.075492f, 0.044508f, 0.092952f), vec3(-0.425903f,-0.203935f,-0.425903f), vec3(0.350411f,-0.350411f,-0.731808f), vec3(0.043935f,-0.054097f, 0.054097f), vec3(-0.247870f, 0.247870f,-0.247870f), vec3(0.203935f, 0.425903f,-0.425903f), vec3(-0.009589f, 0.009589f,-0.011806f), vec3(0.054097f,-0.043935f, 0.054097f), vec3(-0.044508f,-0.075492f, 0.092952f), vec3(0.129714f, 0.076476f,-0.076476f), vec3(-0.731808f,-0.350411f, 0.350411f), vec3(0.602094f,-0.602094f, 0.602094f), vec3(0.075492f,-0.092952f,-0.044508f), vec3(-0.425903f, 0.425903f, 0.203935f), vec3(0.350411f, 0.731808f, 0.350411f), vec3(-0.016476f, 0.016476f, 0.009714f), vec3(0.092952f,-0.075492f,-0.044508f), vec3(-0.076476f,-0.129714f,-0.076476f), }, { vec3(-0.000000f, 0.030000f,-0.000000f), vec3(0.000000f, 0.017460f,-0.000000f), vec3(-0.000000f,-0.003810f, 0.000000f), vec3(0.111270f, 0.000000f, 0.188730f), vec3(-0.135242f, 0.000000f, 0.109839f), vec3(0.023972f,-0.000000f,-0.023972f), vec3(0.000000f,-0.030000f, 0.000000f), vec3(-0.000000f,-0.017460f, 0.000000f), vec3(0.000000f, 0.003810f,-0.000000f), vec3(0.000000f,-0.137460f, 0.000000f), vec3(-0.000000f,-0.080000f, 0.000000f), vec3(0.000000f, 0.017460f,-0.000000f), vec3(-0.509838f,-0.000000f,-1.064759f), vec3(0.619677f,-0.000000f,-0.619677f), vec3(-0.109839f, 0.000000f, 0.135242f), vec3(-0.000000f, 0.137460f,-0.000000f), vec3(0.000000f, 0.080000f,-0.000000f), vec3(-0.000000f,-0.017460f, 0.000000f), vec3(0.000000f,-0.236190f,-0.000000f), vec3(-0.000000f,-0.137460f,-0.000000f), vec3(0.000000f, 0.030000f, 0.000000f), vec3(-0.876029f,-0.000000f, 0.876029f), vec3(1.064759f,-0.000000f, 0.509838f), vec3(-0.188730f, 0.000000f,-0.111270f), vec3(-0.000000f, 0.236190f, 0.000000f), vec3(0.000000f, 0.137460f, 0.000000f), vec3(-0.000000f,-0.030000f,-0.000000f), }, { vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.043649f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.043649f,-0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.274597f), vec3(-0.043649f, 0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.043649f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.200000f, 0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.200000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-1.549194f), vec3(0.200000f,-0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.200000f,-0.000000f), vec3(0.000000f, 0.000000f,-0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), vec3(0.000000f,-0.343649f,-0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.343649f, 0.000000f,-0.000000f), vec3(-0.000000f,-0.000000f, 1.274597f), vec3(0.343649f,-0.000000f, 0.000000f), vec3(-0.000000f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.343649f, 0.000000f), vec3(0.000000f, 0.000000f, 0.000000f), }, { vec3(0.000000f,-0.003810f, 0.000000f), vec3(-0.000000f, 0.017460f,-0.000000f), vec3(0.000000f, 0.030000f,-0.000000f), vec3(-0.023972f,-0.000000f,-0.023972f), vec3(0.135242f, 0.000000f, 0.109839f), vec3(-0.111270f, 0.000000f, 0.188730f), vec3(-0.000000f, 0.003810f,-0.000000f), vec3(0.000000f,-0.017460f, 0.000000f), vec3(-0.000000f,-0.030000f, 0.000000f), vec3(-0.000000f, 0.017460f,-0.000000f), vec3(0.000000f,-0.080000f, 0.000000f), vec3(-0.000000f,-0.137460f, 0.000000f), vec3(0.109839f, 0.000000f, 0.135242f), vec3(-0.619677f,-0.000000f,-0.619677f), vec3(0.509838f,-0.000000f,-1.064759f), vec3(0.000000f,-0.017460f, 0.000000f), vec3(-0.000000f, 0.080000f,-0.000000f), vec3(0.000000f, 0.137460f,-0.000000f), vec3(-0.000000f, 0.030000f, 0.000000f), vec3(0.000000f,-0.137460f,-0.000000f), vec3(-0.000000f,-0.236190f,-0.000000f), vec3(0.188730f, 0.000000f,-0.111270f), vec3(-1.064759f,-0.000000f, 0.509838f), vec3(0.876029f,-0.000000f, 0.876029f), vec3(0.000000f,-0.030000f,-0.000000f), vec3(-0.000000f, 0.137460f, 0.000000f), vec3(0.000000f, 0.236190f, 0.000000f), }, { vec3(-0.009714f,-0.016476f,-0.016476f), vec3(0.011806f,-0.009589f,-0.009589f), vec3(-0.002093f, 0.002093f, 0.002093f), vec3(0.044508f, 0.092952f, 0.075492f), vec3(-0.054097f, 0.054097f, 0.043935f), vec3(0.009589f,-0.011806f,-0.009589f), vec3(0.076476f,-0.076476f, 0.129714f), vec3(-0.092952f,-0.044508f, 0.075492f), vec3(0.016476f, 0.009714f,-0.016476f), vec3(0.044508f, 0.075492f, 0.092952f), vec3(-0.054097f, 0.043935f, 0.054097f), vec3(0.009589f,-0.009589f,-0.011806f), vec3(-0.203935f,-0.425903f,-0.425903f), vec3(0.247870f,-0.247870f,-0.247870f), vec3(-0.043935f, 0.054097f, 0.054097f), vec3(-0.350411f, 0.350411f,-0.731808f), vec3(0.425903f, 0.203935f,-0.425903f), vec3(-0.075492f,-0.044508f, 0.092952f), vec3(0.076476f, 0.129714f,-0.076476f), vec3(-0.092952f, 0.075492f,-0.044508f), vec3(0.016476f,-0.016476f, 0.009714f), vec3(-0.350411f,-0.731808f, 0.350411f), vec3(0.425903f,-0.425903f, 0.203935f), vec3(-0.075492f, 0.092952f,-0.044508f), vec3(-0.602094f, 0.602094f, 0.602094f), vec3(0.731808f, 0.350411f, 0.350411f), vec3(-0.129714f,-0.076476f,-0.076476f), }, { vec3(-0.003810f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.023972f,-0.023972f), vec3(0.003810f,-0.000000f,-0.000000f), vec3(0.017460f,-0.000000f,-0.000000f), vec3(0.000000f, 0.135242f, 0.109839f), vec3(-0.017460f, 0.000000f, 0.000000f), vec3(0.030000f, 0.000000f,-0.000000f), vec3(0.000000f,-0.111270f, 0.188730f), vec3(-0.030000f,-0.000000f, 0.000000f), vec3(0.017460f,-0.000000f,-0.000000f), vec3(0.000000f, 0.109839f, 0.135242f), vec3(-0.017460f, 0.000000f, 0.000000f), vec3(-0.080000f, 0.000000f, 0.000000f), vec3(-0.000000f,-0.619677f,-0.619677f), vec3(0.080000f,-0.000000f,-0.000000f), vec3(-0.137460f,-0.000000f, 0.000000f), vec3(-0.000000f, 0.509838f,-1.064759f), vec3(0.137460f, 0.000000f,-0.000000f), vec3(0.030000f,-0.000000f, 0.000000f), vec3(0.000000f, 0.188730f,-0.111270f), vec3(-0.030000f, 0.000000f,-0.000000f), vec3(-0.137460f, 0.000000f,-0.000000f), vec3(-0.000000f,-1.064759f, 0.509838f), vec3(0.137460f,-0.000000f, 0.000000f), vec3(-0.236190f,-0.000000f,-0.000000f), vec3(-0.000000f, 0.876029f, 0.876029f), vec3(0.236190f, 0.000000f, 0.000000f), }, { vec3(0.002093f, 0.002093f, 0.002093f), vec3(-0.011806f,-0.009589f,-0.009589f), vec3(0.009714f,-0.016476f,-0.016476f), vec3(-0.009589f,-0.011806f,-0.009589f), vec3(0.054097f, 0.054097f, 0.043935f), vec3(-0.044508f, 0.092952f, 0.075492f), vec3(-0.016476f, 0.009714f,-0.016476f), vec3(0.092952f,-0.044508f, 0.075492f), vec3(-0.076476f,-0.076476f, 0.129714f), vec3(-0.009589f,-0.009589f,-0.011806f), vec3(0.054097f, 0.043935f, 0.054097f), vec3(-0.044508f, 0.075492f, 0.092952f), vec3(0.043935f, 0.054097f, 0.054097f), vec3(-0.247870f,-0.247870f,-0.247870f), vec3(0.203935f,-0.425903f,-0.425903f), vec3(0.075492f,-0.044508f, 0.092952f), vec3(-0.425903f, 0.203935f,-0.425903f), vec3(0.350411f, 0.350411f,-0.731808f), vec3(-0.016476f,-0.016476f, 0.009714f), vec3(0.092952f, 0.075492f,-0.044508f), vec3(-0.076476f, 0.129714f,-0.076476f), vec3(0.075492f, 0.092952f,-0.044508f), vec3(-0.425903f,-0.425903f, 0.203935f), vec3(0.350411f,-0.731808f, 0.350411f), vec3(0.129714f,-0.076476f,-0.076476f), vec3(-0.731808f, 0.350411f, 0.350411f), vec3(0.602094f, 0.602094f, 0.602094f), }, };

template<FemShape Shape> constexpr uint32_t VolumeMult = 0;
template<> constexpr float VolumeMult<FemShape::Tri> = 1.0f / 2.0f;
template<> constexpr float VolumeMult<FemShape::Tet> = 1.0f / 6.0f;
template<> constexpr float VolumeMult<FemShape::Quad> = 1.0f;
template<> constexpr float VolumeMult<FemShape::Hex> = 1.0f;

//-----------------------------------------------------------------------------
// Helper for multiplying larger rectangular matrices made of arrays of vecs
template<typename Vec, uint32_t N>
inline auto MatMul(const Vec(&vecsAreColumns)[N], const Vec(&vecsAreRows)[N]) {
	using Mat = decltype(outerProduct(Vec(), Vec()));
	Mat result = Mat(0.0f);
	for (uint32_t n = 0; n < N; n++) {
		result += outerProduct(vecsAreColumns[n], vecsAreRows[n]);
	}
	return result;
}

// The jacobian at a point is just the shape function gradient multiplied by the nodes
template<FemShape Shape, uint32_t Points, typename Vec, uint32_t MapNodes>
inline auto GenerateMapJacobian(uint32_t p, const Vec(&P)[MapNodes]) {
	return MatMul(ShapeFunctionGradients<Shape, MapNodes, Points>[p], P);
}

//-----------------------------------------------------------------------------
// Element initialization

//---------------------------------------------------------
// Coefficient/weight generation for affine-mapped quads/hexes.
// Unlike tris/tets, which always have a constant Qi, non-parallelogram
// quads/hexs have a jacobian that varies across the shape, so we
// precalculate it at each quadrature point.
template<FemShape Shape, typename Vec, uint32_t Nodes, uint32_t Points, uint32_t MapNodes>
inline void GenerateMappedQuadratureCoefficients(QuadratureCoefficients<Vec, Nodes, Points>* d, const Vec(&P)[MapNodes]) {
	float volume = 0.0f;
	for (uint32_t p = 0; p < Points; p++) {
		auto J = GenerateMapJacobian<Shape, Points>(p, P);
		float detJ = determinant(J);
		auto Ji = inverse(J);
		d->Ji[p] = Ji;
		d->w[p] = detJ * QuadratureWeights<Shape, Points>[p];
		volume += d->w[p];
	}
	for (uint32_t p = 0; p < Points; p++) {
		d->w[p] /= volume;
	}
}

//---------------------------------------------------------
// Different way of numerically integrating the Neo-Hookean term.
// Pre-integrates all the combinations of shape function gradients,
// generally yielding faster runtime and lower memory usage
// (compared to storing the jacobians needed for full quadrature).
template<FemShape Shape, typename Vec, uint32_t Nodes, uint32_t MapNodes>
inline void GeneratePrefactoredCoefficients(PrefactoredIntegrationCoefficients<Vec, Nodes>* d, const Vec(&P)[MapNodes]) {
	using Mat = decltype(outerProduct(Vec(), Vec()));
	const uint32_t QRNodes = ((Nodes - 1) * (Nodes - 2)) / 2;
	const uint32_t Points = Nodes == 6 ? 7 : Nodes;
	float volume = 0.0f;
	for (uint32_t i = 0; i < Nodes - 1; i++) { d->QQ[i] = 0.0f; }
	for (uint32_t i = 0; i < QRNodes; i++) { d->QR[i] = 0.0f; }
	// Calculate integrals of all combinations of mapped shape function gradients
	const float dims = dot(Vec(1.0f), Vec(1.0f));
	for (uint32_t p = 0; p < Points; p++) {
		const Vec(&dN)[Nodes] = ShapeFunctionGradients<Shape, Nodes, Points>[p];
		Mat J = GenerateMapJacobian<Shape, Points>(p, P);
		Mat Ji = inverse(J);
		float w = determinant(J) * VolumeMult<Shape> * QuadratureWeights<Shape, Points>[p];
		Vec Qi[Nodes - 1];
		for (uint32_t i = 0; i < Nodes - 1; i++) { Qi[i] = Ji * dN[i]; }
		volume += w;
		for (uint32_t i = 0; i < Nodes - 1; i++) {
			d->QQ[i] += w * dot(Qi[i], Qi[i]);
		}
		uint32_t head = 0;
		for (uint32_t i = 0; i < Nodes - 1; i++) {
			for (uint32_t j = i + 1; j < Nodes - 1; j++) {
				d->QR[head++] += w * 2.0f * dot(Qi[i], Qi[j]);
			}
		}
	}
	for (uint32_t i = 0; i < Nodes - 1; i++) { d->QQ[i] /= volume; }
	for (uint32_t i = 0; i < QRNodes; i++) { d->QR[i] /= volume; }
}

template<typename Vec, uint32_t Nodes>
inline void CalculateIncompressibleNeoHookeanEnergyAndGradients(const PrefactoredIntegrationCoefficients<Vec, Nodes>& d, Vec(&P)[Nodes - 1], float* outU, Vec(&outg)[Nodes]) {
	float& U = *outU;
	Vec(&g)[Nodes] = outg;

	// Apply terms of the polynomial to potential energy and gradients
	U = 0.0f;
	// Apply the i squared terms ...
	for (uint32_t i = 0; i < Nodes - 1; i++) {
		U += d.QQ[i] * dot(P[i], P[i]);
		g[i] = 2.0f * d.QQ[i] * P[i];
	}

	// Apply the i*j off-diagonal terms ...
	uint32_t k = 0;
	for (uint32_t i = 0; i < Nodes - 1; i++) {
		for (uint32_t j = i + 1; j < Nodes - 1; j++) {
			U += d.QR[k] * dot(P[i], P[j]);
			g[i] += d.QR[k] * P[j];
			g[j] += d.QR[k] * P[i];
			++k;
		}
	}

	// The root node's gradient is the negative sum of all other gradients
	g[Nodes - 1] = Vec(0.0f);
	for (uint32_t i = 0; i < Nodes - 1; i++) {
		g[Nodes - 1] -= g[i];
	}
}

//---------------------------------------------------------
// InitFiniteElement functions
template<FemShape Shape, typename Dvec, typename ElementParams, uint32_t Nodes, uint32_t MapNodes>
void InitTriTetFiniteElement(Dvec* X, const uint32_t(&is)[Nodes], float density, float* m, ElementParams* ep, const uint32_t(&mapIdxs)[MapNodes]) {
	using Vec = typename Dvec::vec;

	// Init the ElementParams
	Vec P[MapNodes];
	for (uint32_t n = 0; n < MapNodes; n++) { P[n] = Vec(X[mapIdxs[n]] - X[mapIdxs[MapNodes - 1]]); }
	auto J = GenerateMapJacobian<Shape, 1>(0, P);
	ep->Qi = inverse(J);
	GeneratePrefactoredCoefficients<ElementParams::Shape>(&ep->ic, P);
	if constexpr (MapNodes == 3) {
		ep->volume = (1.0f / 2.0f) * determinant(J);
		ep->surfaceArea = distance(P[0], P[1]) + distance(P[1], P[2]) + distance(P[2], P[0]);
	} else {
		ep->volume = (1.0f / 6.0f) * determinant(J);
		auto FaceArea = [&](uint32_t i0, uint32_t i1, uint32_t i2) {
			return 0.5f * length(cross(P[i0] - P[i2], P[i1] - P[i2]));
		};
		ep->surfaceArea = FaceArea(0, 1, 2) + FaceArea(1, 3, 2) + FaceArea(0, 2, 3) + FaceArea(3, 1, 0);
	}

	// Perform mass lumping. Since linearly mapped tris/tets have constant jacobians, mass distributions can be pre-calculated
	const float LumpsTri3[4] = { 1.0f, 1.0f, 1.0f, 3.0f }; // The last element is the sum of all previous elements
	const float LumpsTri6[7] = { 3.0f, 3.0f, 3.0f, 16.0f, 16.0f, 16.0f, 57.0f };
	const float LumpsTet4[5] = { 1.0f, 1.0f, 1.0f, 1.0f, 4.0f };
	const float LumpsTet10[11] = { 13.0f, 13.0f, 13.0f, 13.0f, 70.0f, 70.0f, 70.0f, 70.0f, 70.0f, 70.0f, 472.0f };
	const float* Lumps = Nodes == 3 ? LumpsTri3 : Nodes == 6 ? LumpsTri6 : Nodes == 4 ? LumpsTet4 : LumpsTet10;
	for (uint32_t n = 0; n < Nodes; n++) { m[is[n]] += (Lumps[n] / Lumps[Nodes]) * density * ep->volume; }
}
template<FemShape Shape, typename Dvec, typename ElementParams, uint32_t Nodes, uint32_t MapNodes>
void InitQuadHexFiniteElement(Dvec* X, const uint32_t(&is)[Nodes], float density, float* m, ElementParams* ep, const uint32_t(&mapIdxs)[MapNodes]) {
	using Vec = typename Dvec::vec;

	// Init the ElementParams
	Vec P[MapNodes];
	for (uint32_t n = 0; n < MapNodes; n++) { P[n] = Vec(X[mapIdxs[n]] - X[mapIdxs[MapNodes - 1]]); }
	GenerateMappedQuadratureCoefficients<ElementParams::Shape>(&ep->qcLo, P);
	GenerateMappedQuadratureCoefficients<ElementParams::Shape>(&ep->qcHi, P);
	GeneratePrefactoredCoefficients<ElementParams::Shape>(&ep->ic, P);
	ep->volume = 0.0f;
	const uint32_t VolPoints = MapNodes;
	for (uint32_t p = 0; p < VolPoints; p++) {
		auto J = GenerateMapJacobian<Shape, VolPoints>(p, P);
		ep->volume += determinant(J) * QuadratureWeights<Shape, VolPoints>[p];
	}
	if constexpr (MapNodes == 4) {
		ep->surfaceArea = distance(P[0], P[1]) + distance(P[1], P[2]) + distance(P[2], P[3]) + distance(P[3], P[0]);
	} else if constexpr (MapNodes == 8) {
		auto FaceArea = [&](uint32_t i0, uint32_t i1, uint32_t i2, uint32_t i3) {
			return 0.5f * length(cross(P[i0] - P[i3], P[i1] - P[i2]));
		};
		ep->surfaceArea =
			FaceArea(0, 1, 2, 3) + FaceArea(4, 5, 6, 7) +
			FaceArea(0, 1, 4, 5) + FaceArea(2, 3, 6, 7) +
			FaceArea(0, 2, 4, 6) + FaceArea(1, 3, 5, 7);
	}

	// Perform mass lumping. Unlike tris/tets, the map jacobian of a quad/hex can vary across the element,
	// so we can't precompute weights. Instead, we use the normalized diagonal of the mass matrix
	float mmd[Nodes] = { 0.0f }; // <-- Mass Matrix Diagonal
	float mmdSum = 0.0f;
	for (uint32_t p = 0; p < ElementParams::PointsHi; p++) {
		float w = ep->qcHi.w[p];
		for (uint32_t n = 0; n < Nodes; n++) {
			float Nn = ShapeFunctions<Shape, Nodes, ElementParams::PointsHi>[p][n];
			mmd[n] += w * Nn * Nn;
			mmdSum += w * Nn * Nn;
		}
	}
	for (uint32_t n = 0; n < Nodes; n++) { m[is[n]] += (mmd[n] / mmdSum) * density * ep->volume; }
}
void InitFiniteElement(const dvec2* X, const uint32_t(&is)[3], float density, float* m, ElementParamsLinearTri* ep) { InitTriTetFiniteElement<FemShape::Tri>(X, is, density, m, ep, is); }
void InitFiniteElement(const dvec2* X, const uint32_t(&is)[6], float density, float* m, ElementParamsQuadraticTri* ep) { InitTriTetFiniteElement<FemShape::Tri>(X, is, density, m, ep, { is[0], is[1], is[2] }); }
void InitFiniteElement(const dvec3* X, const uint32_t(&is)[4], float density, float* m, ElementParamsLinearTet* ep) { InitTriTetFiniteElement<FemShape::Tet>(X, is, density, m, ep, is); }
void InitFiniteElement(const dvec3* X, const uint32_t(&is)[10], float density, float* m, ElementParamsQuadraticTet* ep) { InitTriTetFiniteElement<FemShape::Tet>(X, is, density, m, ep, { is[0], is[1], is[2], is[3] }); }
void InitFiniteElement(const dvec2* X, const uint32_t(&is)[4], float density, float* m, ElementParamsLinearQuad* ep) { InitQuadHexFiniteElement<FemShape::Quad>(X, is, density, m, ep, is); }
void InitFiniteElement(const dvec2* X, const uint32_t(&is)[9], float density, float* m, ElementParamsQuadraticQuad* ep) { InitQuadHexFiniteElement<FemShape::Quad>(X, is, density, m, ep, { is[0], is[1], is[2], is[3] }); }
void InitFiniteElement(const dvec3* X, const uint32_t(&is)[8], float density, float* m, ElementParamsLinearHex* ep) { InitQuadHexFiniteElement<FemShape::Hex>(X, is, density, m, ep, is); }
void InitFiniteElement(const dvec3* X, const uint32_t(&is)[27], float density, float* m, ElementParamsQuadraticHex* ep) { InitQuadHexFiniteElement<FemShape::Hex>(X, is, density, m, ep, { is[0], is[2], is[6], is[8], is[18], is[20], is[24], is[26] }); }

//-----------------------------------------------------------------------------
// Simulation functions

//---------------------------------------------------------
// Sim helpers
inline mat2 adjugate(const mat2& m) {
	return mat2(vec2(m[1][1], -m[0][1]), vec2(-m[1][0], m[0][0]));
};
inline mat3 adjugate(const mat3& m) {
	float m00 = m[0][0], m01 = m[0][1], m02 = m[0][2];
	float m10 = m[1][0], m11 = m[1][1], m12 = m[1][2];
	float m20 = m[2][0], m21 = m[2][1], m22 = m[2][2];

	mat3 adj;
	adj[0][0] = +(m11 * m22 - m12 * m21);
	adj[0][1] = -(m01 * m22 - m02 * m21);
	adj[0][2] = +(m01 * m12 - m02 * m11);
	adj[1][0] = -(m10 * m22 - m12 * m20);
	adj[1][1] = +(m00 * m22 - m02 * m20);
	adj[1][2] = -(m00 * m12 - m02 * m10);
	adj[2][0] = +(m10 * m21 - m11 * m20);
	adj[2][1] = -(m00 * m21 - m01 * m20);
	adj[2][2] = +(m00 * m11 - m01 * m10);
	return adj;
};
inline float determinantFromAdjugate(const mat2& m, const mat2& adj) {
	return dot(m[0], vec2(adj[0][0], adj[1][0]));
}
inline float determinantFromAdjugate(const mat3& m, const mat3& adj) {
	return dot(m[0], vec3(adj[0][0], adj[1][0], adj[2][0]));
}

inline float traceXTX(const mat2& F) { return dot(F[0], F[0]) + dot(F[1], F[1]); }
inline float traceXTX(const mat3& F) { return dot(F[0], F[0]) + dot(F[1], F[1]) + dot(F[2], F[2]); }

template<uint32_t Points, typename Vec, typename ElementParams, uint32_t PNodes, uint32_t Nodes = PNodes + 1>
inline auto CalculateDeformationGradient(const ElementParams& ep, Vec(&P)[PNodes], uint32_t p) {
	const Vec(&dN)[Nodes - 1] = (const Vec(&)[Nodes - 1])ShapeFunctionGradients<ElementParams::Shape, Nodes, Points>[p];
	if constexpr (ElementParams::Shape == FemShape::Tri || ElementParams::Shape == FemShape::Tet) {
		return ep.Qi * MatMul(dN, P);
	} else {
		if constexpr (Points == ElementParams::PointsLo) {
			return ep.qcLo.Ji[p] * MatMul(dN, P);
		} else {
			return ep.qcHi.Ji[p] * MatMul(dN, P);
		}
	}
}

template<uint32_t Points, typename ElementParams>
inline float CalculateQuadratureWeight(const ElementParams& ep, uint32_t p) {
	if constexpr (ElementParams::Shape == FemShape::Tri || ElementParams::Shape == FemShape::Tet) {
		return QuadratureWeights<ElementParams::Shape, Points>[p];
	} else {
		if constexpr (Points == ElementParams::PointsLo) {
			return ep.qcLo.w[p];
		} else {
			return ep.qcHi.w[p];
		}
	}
}

template<uint32_t Points, typename Mat, typename Vec, typename ElementParams, uint32_t Nodes>
inline void ApplyEnergyGradient(const ElementParams& ep, Vec(&g)[Nodes], const Mat& G, uint32_t p) {
	Mat Qi;
	if constexpr (ElementParams::Shape == FemShape::Tri || ElementParams::Shape == FemShape::Tet) {
		Qi = G * ep.Qi;
	} else {
		if constexpr (Points == ElementParams::PointsLo) {
			Qi = G * ep.qcLo.Ji[p];
		} else {
			Qi = G * ep.qcHi.Ji[p];
		}
	}
	const Vec(&dN)[Nodes] = ShapeFunctionGradients<ElementParams::Shape, Nodes, Points>[p];
	for (uint32_t n = 0; n < Nodes - 1; n++) {
		g[n] += Qi * dN[n];
	}
}

enum class DampingMode { On, Off };

//---------------------------------------------------------
// Meat of the sim logic in the following 3 functions
enum class PixarOptions { Full, Reduced, Selective };
template<PixarOptions Options, typename Dvec, typename ElementParams, uint32_t Nodes>
inline void SolveElementPixar(DampingMode dampingMode, float dt, Dvec* __restrict X, const Dvec* O, Dvec* __restrict V, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, const Settings& settings) {
	using Vec = typename Dvec::vec;

	const uint32_t RayleighType = (settings.flags >> Settings_RayleighTypeBit) & Settings_RayleighTypeMask;

	float mu = 2.0f;
	float lambda = mu / (1.0f - 2.0f * settings.poissonsRatio);

	float comp = settings.compliance / ep.volume;
	float damp = settings.damping;

	Vec P[Nodes - 1];
	for (uint32_t i = 0; i < Nodes - 1; i++) { P[i] = Vec(X[is[i]] - X[is[Nodes - 1]]); }

	float U = 0.0f;
	Vec g[Nodes];
	for (uint32_t n = 0; n < Nodes; n++) { g[n] = Vec(0.0f); }

	if constexpr (Options == PixarOptions::Full || Options == PixarOptions::Reduced) {
		const uint32_t Points = Options == PixarOptions::Full ? ElementParams::PointsHi : ElementParams::PointsLo;
		for (uint32_t p = 0; p < Points; p++) {
			// Strain energy from Pixar's Stable Neo-Hookean Flesh Simulation
			auto F = CalculateDeformationGradient<Points>(ep, P, p);
			float weight = CalculateQuadratureWeight<Points>(ep, p);

			// Deviatoric
			float I1 = traceXTX(F);
			U += weight * (mu / 2.0f) * I1;

			// Hydrostatic
			auto adjF = adjugate(F);
			float J = determinantFromAdjugate(F, adjF);
			float a = 1.0f + mu / lambda;
			U += weight * (lambda / 2.0f) * ((J - a) * (J - a));

			// Apply gradients
			auto GI1 = (weight * (mu / 2.0f) * 2.0f) * transpose(F);
			auto GJ = (weight * (lambda / 2.0f) * 2.0f * (J - a)) * adjF;
			ApplyEnergyGradient<Points>(ep, g, GI1 + GJ, p);
		}
		for (uint32_t n = 0; n < Nodes - 1; n++) { g[Nodes - 1] -= g[n]; }
	} else {
		const uint32_t Points = ElementParams::PointsLo;
		for (uint32_t p = 0; p < Points; p++) {
			auto F = CalculateDeformationGradient<Points>(ep, P, p);
			float weight = CalculateQuadratureWeight<Points>(ep, p);

			// Hydrostatic
			auto adjF = adjugate(F);
			float J = determinantFromAdjugate(F, adjF);
			float a = 1.0f + mu / lambda;
			U += weight * (lambda / 2.0f) * ((J - a) * (J - a));

			// Apply gradients
			auto GJ = (weight * (lambda / 2.0f) * 2.0f * (J - a)) * adjF;
			ApplyEnergyGradient<Points>(ep, g, GJ, p);
		}
		for (uint32_t n = 0; n < Nodes - 1; n++) { g[Nodes - 1] -= g[n]; }

		float UI1 = 0.0f;
		Vec gI1[Nodes];
		CalculateIncompressibleNeoHookeanEnergyAndGradients(ep.ic, P, &UI1, gI1);
		U += (mu / 2.0f) * UI1;
		for (uint32_t n = 0; n < Nodes; n++) { g[n] += (mu / 2.0f) * gI1[n]; }
	}

	if (dampingMode == DampingMode::On) {
		RayleighDamp(Nodes, V, w, is, U, g, dt, comp, damp);
	} else {
		EnergyXpbdConstrain(Nodes, X, O, w, is, U, g, dt, comp, damp, RayleighType);
	}
}

enum class MixedOptions { Mixed, MixedSelective, YeohSkin, YeohSkinSelective, YeohSkinFast };
enum class SolveOptions { Serial, Simultaneous };
template<MixedOptions Options, typename Dvec, typename ElementParams, uint32_t Nodes>
inline void SolveElementMixed(DampingMode dampingMode, float dt, Dvec* __restrict X, const Dvec* O, Dvec* __restrict V, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, const Settings& settings) {
	using Vec = typename Dvec::vec;

	const uint32_t RayleighType = (settings.flags >> Settings_RayleighTypeBit) & Settings_RayleighTypeMask;
	SolveOptions Solve = (settings.flags & (1 << Settings_XpbdSolveBit)) ? SolveOptions::Simultaneous : SolveOptions::Serial;
	if (dampingMode == DampingMode::On) { Solve = SolveOptions::Simultaneous; }

	float mu = 1.0f / settings.compliance;
	float lambda = (2.0f * mu * settings.poissonsRatio) / (1.0f - 2.0f * settings.poissonsRatio);
	float a = 1.0f + mu / lambda;

	float comp[2] = { 1.0f / mu / ep.volume, 1.0f / lambda / ep.volume };
	float damp[2] = { settings.damping, settings.damping };

	Vec P[Nodes - 1];
	for (uint32_t i = 0; i < Nodes - 1; i++) { P[i] = Vec(X[is[i]] - X[is[Nodes - 1]]); }

	float U[2] = { 0.0f };
	Vec g[2][Nodes];
	for (uint32_t n = 0; n < Nodes; n++) { g[0][n] = Vec(0.0f); g[1][n] = Vec(0.0f); }

	if constexpr (Options == MixedOptions::Mixed || Options == MixedOptions::YeohSkin || Options == MixedOptions::YeohSkinSelective) {
		const uint32_t Points = ElementParams::PointsHi;
		for (uint32_t p = 0; p < Points; p++) {
			auto F = CalculateDeformationGradient<Points>(ep, P, p);
			float weight = CalculateQuadratureWeight<Points>(ep, p);

			float I1 = traceXTX(F);
			if constexpr (Options == MixedOptions::Mixed) {
				U[0] += weight * I1;
				auto GI1 = (weight * 2.0f) * transpose(F);
				ApplyEnergyGradient<Points>(ep, g[0], GI1, p);
			} else {
				const float C[3] = { 0.1095f, 14.95f, 4.595f };
				float IM; if constexpr (sizeof(Vec) == sizeof(vec2)) { IM = I1 - 2.0f; } else { IM = I1 - 3.0f; }
				U[0] += weight * (C[0] * IM + C[1] * IM * IM + C[2] * IM * IM * IM);
				auto GY = (weight * (C[0] + 2.0f * C[1] * IM + 3.0f * C[2] * IM * IM) * 2.0f) * transpose(F);
				ApplyEnergyGradient<Points>(ep, g[0], GY, p);
			}

			if (Solve == SolveOptions::Simultaneous && Options != MixedOptions::YeohSkinSelective) {
				auto adjF = adjugate(F);
				float J = determinantFromAdjugate(F, adjF);
				U[1] += weight * ((J - a) * (J - a));
				auto GJ = (weight * 2.0f * (J - a)) * adjF;
				ApplyEnergyGradient<Points>(ep, g[1], GJ, p);
			}
		}
		U[0] = max(0.0001f, U[0]);
		if (Solve == SolveOptions::Simultaneous) {
			if constexpr (Options == MixedOptions::YeohSkinSelective) {
				const uint32_t Points = ElementParams::PointsLo;
				for (uint32_t p = 0; p < Points; p++) {
					auto F = CalculateDeformationGradient<Points>(ep, P, p);
					float weight = CalculateQuadratureWeight<Points>(ep, p);
					auto adjF = adjugate(F);
					float J = determinantFromAdjugate(F, adjF);
					U[1] += weight * ((J - a) * (J - a));
					auto GJ = (weight * 2.0f * (J - a)) * adjF;
					ApplyEnergyGradient<Points>(ep, g[1], GJ, p);
				}
			}
			for (uint32_t n = 0; n < Nodes - 1; n++) { g[0][Nodes - 1] -= g[0][n]; g[1][Nodes - 1] -= g[1][n]; }
			if (dampingMode == DampingMode::Off) {
				EnergyXpbdConstrainSimultaneous(Nodes, X, O, w, is, U, (Vec*)g, dt, comp, damp, RayleighType);
			}
		} else {
			for (uint32_t n = 0; n < Nodes - 1; n++) { g[0][Nodes - 1] -= g[0][n]; }
			EnergyXpbdConstrain(Nodes, X, O, w, is, U[0], g[0], dt, comp[0], damp[0], RayleighType);
			for (uint32_t i = 0; i < Nodes - 1; i++) { P[i] = Vec(X[is[i]] - X[is[Nodes - 1]]); }

			const uint32_t Points = Options == MixedOptions::YeohSkinSelective ? ElementParams::PointsLo : ElementParams::PointsHi;
			for (uint32_t p = 0; p < Points; p++) {
				auto F = CalculateDeformationGradient<Points>(ep, P, p);
				float weight = CalculateQuadratureWeight<Points>(ep, p);
				auto adjF = adjugate(F);
				float J = determinantFromAdjugate(F, adjF);
				U[1] += weight * ((J - a) * (J - a));
				auto GJ = (weight * 2.0f * (J - a)) * adjF;
				ApplyEnergyGradient<Points>(ep, g[1], GJ, p);
			}

			for (uint32_t n = 0; n < Nodes - 1; n++) { g[1][Nodes - 1] -= g[1][n]; }
			EnergyXpbdConstrain(Nodes, X, O, w, is, U[1], g[1], dt, comp[1], damp[1], RayleighType);
		}
	} else { // if (Options == MixedOptions::MixedSelective && Options == MixedOptions::YeohSkinFast) {
		CalculateIncompressibleNeoHookeanEnergyAndGradients(ep.ic, P, &U[0], g[0]);
		if constexpr (Options == MixedOptions::YeohSkinFast) {
			const float C[3] = { 0.1095f, 14.95f, 4.595f };
			float IM; if constexpr (sizeof(Vec) == sizeof(vec2)) { IM = U[0] - 2.0f; } else { IM = U[0] - 3.0f; }
			U[0] = max(0.0001f, C[0] * IM + C[1] * IM * IM + C[2] * IM * IM * IM);
			float gScale = C[0] + 2.0f * C[1] * IM + 3.0f * C[2] * IM * IM;
			for (uint32_t n = 0; n < Nodes; n++) { g[0][n] *= gScale; }
		}
		if (Solve == SolveOptions::Serial) {
			EnergyXpbdConstrain(Nodes, X, O, w, is, U[0], g[0], dt, comp[0], damp[0], RayleighType);
			for (uint32_t n = 0; n < Nodes - 1; n++) { P[n] = Vec(X[is[n]] - X[is[Nodes - 1]]); }
		}

		const uint32_t Points = ElementParams::PointsLo;
		for (uint32_t p = 0; p < Points; p++) {
			auto F = CalculateDeformationGradient<Points>(ep, P, p);
			float weight = CalculateQuadratureWeight<Points>(ep, p);
			auto adjF = adjugate(F);
			float J = determinantFromAdjugate(F, adjF);
			U[1] += weight * ((J - a) * (J - a));
			auto GJ = (weight * 2.0f * (J - a)) * adjF;
			ApplyEnergyGradient<Points>(ep, g[1], GJ, p);
		}
		for (uint32_t n = 0; n < Nodes - 1; n++) { g[1][Nodes - 1] -= g[1][n]; }
		if (Solve == SolveOptions::Serial) {
			EnergyXpbdConstrain(Nodes, X, O, w, is, U[1], g[1], dt, comp[1], damp[1], RayleighType);
		} else if (dampingMode == DampingMode::Off) {
			EnergyXpbdConstrainSimultaneous(Nodes, X, O, w, is, U, (Vec*)g, dt, comp, damp, RayleighType);
		}
	}

	if (dampingMode == DampingMode::On) {
		SolveOptions DampSolve = (settings.flags & (1 << Settings_XpbdSolveBit)) ? SolveOptions::Simultaneous : SolveOptions::Serial;
		if (DampSolve == SolveOptions::Simultaneous) {
			RayleighDamp(Nodes, V, w, is, U, (Vec*)g, dt, comp, damp);
		} else {
			RayleighDamp(Nodes, V, w, is, U[0], g[0], dt, comp[0], damp[0]);
			RayleighDamp(Nodes, V, w, is, U[1], g[1], dt, comp[1], damp[1]);
		}
	}
}

enum class CubeOptions { Neo, Skin };
template<CubeOptions Options, typename Dvec, typename ElementParams, uint32_t Nodes>
inline void SolveElementCube(DampingMode dampingMode, float dt, Dvec* __restrict X, const Dvec* O, Dvec* __restrict V, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, const Settings& settings) {
	// For demonstration purposes, under ideal conditions we run a very simple version of the algorithm
	if constexpr (Options == CubeOptions::Neo && ElementParams::Shape == FemShape::Quad && Nodes == 4) {
		if (settings.poissonsRatio >= 0.5f && settings.damping <= 0.0f) {
			// Translate some values
			float complianceTimesMass = settings.compliance / ((1.0f / 4.0f) * (w[is[0]] + w[is[1]] + w[is[2]] + w[is[3]]));
			float area0 = ep.volume;

			// Apply Neo-Hookean compression
			dvec2 centroid = (1.0 / 4.0) * (X[is[0]] + X[is[1]] + X[is[2]] + X[is[3]]);
			float compressionScale = -2.0f * dt * dt / complianceTimesMass;
			X[is[0]] += compressionScale * (X[is[0]] - centroid);
			X[is[1]] += compressionScale * (X[is[1]] - centroid);
			X[is[2]] += compressionScale * (X[is[2]] - centroid);
			X[is[3]] += compressionScale * (X[is[3]] - centroid);

			// Apply volume conservation
			vec2 A = vec2(X[is[0]] - X[is[2]]);
			vec2 B = vec2(X[is[1]] - X[is[3]]);
			float area = 0.5f * (A.x * B.y - A.y * B.x);
			vec2 gA = 0.5f * vec2(B.y, -B.x); // Partial derivative of area with respect to A
			vec2 gB = 0.5f * vec2(-A.y, A.x); // Partial derivative of area with respect to B
			float volumeScale = -2.0f * (area - area0) / (dot(A, A) + dot(B, B));
			X[is[0]] += dvec2(volumeScale * gA);
			X[is[1]] += dvec2(volumeScale * gB);
			X[is[2]] -= dvec2(volumeScale * gA);
			X[is[3]] -= dvec2(volumeScale * gB);

			return;
		}
	}
	if constexpr (Options == CubeOptions::Neo && ElementParams::Shape == FemShape::Hex && Nodes == 8) {
		if (settings.poissonsRatio >= 0.5f && settings.damping <= 0.0f) {
			// Translate some values
			float complianceTimesMass = settings.compliance / ((1.0f / 8.0f) * (w[is[0]] + w[is[1]] + w[is[2]] + w[is[3]] + w[is[4]] + w[is[5]] + w[is[6]] + w[is[7]]));
			float sideLength = ep.volume / (ep.surfaceArea * (1.0f / 6.0f));

			// Apply Neo-Hookean compression
			dvec3 centroid = (1.0 / 8.0) * (X[is[0]] + X[is[1]] + X[is[2]] + X[is[3]] + X[is[4]] + X[is[5]] + X[is[6]] + X[is[7]]);
			float compressionScale = -2.0f * dt * dt / complianceTimesMass * (0.5f * sideLength);
			X[is[0]] += compressionScale * (X[is[0]] - centroid);
			X[is[1]] += compressionScale * (X[is[1]] - centroid);
			X[is[2]] += compressionScale * (X[is[2]] - centroid);
			X[is[3]] += compressionScale * (X[is[3]] - centroid);
			X[is[4]] += compressionScale * (X[is[4]] - centroid);
			X[is[5]] += compressionScale * (X[is[5]] - centroid);
			X[is[6]] += compressionScale * (X[is[6]] - centroid);
			X[is[7]] += compressionScale * (X[is[7]] - centroid);

			// Apply volume conservation
			mat3 F = transpose(mat3(
				vec3(-X[is[0]] + X[is[1]] - X[is[2]] + X[is[3]] - X[is[4]] + X[is[5]] - X[is[6]] + X[is[7]]),
				vec3(-X[is[0]] - X[is[1]] + X[is[2]] + X[is[3]] - X[is[4]] - X[is[5]] + X[is[6]] + X[is[7]]),
				vec3(-X[is[0]] - X[is[1]] - X[is[2]] - X[is[3]] + X[is[4]] + X[is[5]] + X[is[6]] + X[is[7]])));
			mat3 adjF = adjugate(F) * 1.0f / 64.0f;
			float detF = determinantFromAdjugate(F, adjF);
			float volume = detF;
			vec3 g[8];
			g[0] = -adjF[0] - adjF[1] - adjF[2]; // These are partial derivatives of detF/volume64 with respect to each X
			g[1] = +adjF[0] - adjF[1] - adjF[2];
			g[2] = -adjF[0] + adjF[1] - adjF[2];
			g[3] = +adjF[0] + adjF[1] - adjF[2];
			g[4] = -adjF[0] - adjF[1] + adjF[2];
			g[5] = +adjF[0] - adjF[1] + adjF[2];
			g[6] = -adjF[0] + adjF[1] + adjF[2];
			g[7] = +adjF[0] + adjF[1] + adjF[2];
			float dots = dot(adjF[0], adjF[0]) + dot(adjF[1], adjF[1]) + dot(adjF[2], adjF[2]);
			float volumeScale = (volume - ep.volume) / (8.0f * dots);
			for (uint32_t n = 0; n < 8; n++) { X[is[n]] -= dvec3(volumeScale * g[n]); }

			return;
		}
	}

	// Otherwise, we run a slower (but still quite fast) version of the algorithm that borrows more from the exact solution
	if constexpr ((ElementParams::Shape == FemShape::Quad && Nodes == 4) || (ElementParams::Shape == FemShape::Hex && Nodes == 8)) {
		using Vec = typename Dvec::vec;

		const uint32_t RayleighType = (settings.flags >> Settings_RayleighTypeBit) & Settings_RayleighTypeMask;

		float lameMu = 1.0f / settings.compliance;
		float lameLambda = (2.0f * lameMu * settings.poissonsRatio) / (1.0f - 2.0f * settings.poissonsRatio);
		float a = 1.0f + lameMu / lameLambda;

		Dvec centroid = X[is[0]];
		for (uint32_t n = 1; n < Nodes; n++) { centroid += X[is[n]]; }
		centroid *= (1.0 / (double)Nodes);

		Vec P[Nodes];
		for (uint32_t n = 0; n < Nodes; n++) { P[n] = Vec(X[is[n]] - centroid); }

		// Apply Neo-Hookean
		{
			float UI = 0.0f;
			float PPw = 0.0f;
			for (uint32_t n = 0; n < Nodes; n++) {
				float PP = dot(P[n], P[n]);
				UI += PP;
				PPw += w[is[n]] * PP;
			}
			float UScale;
			if constexpr (sizeof(Vec) == sizeof(vec2)) {
				UScale = 1.0f / ep.volume;
			} else {
				UScale = 0.5f / ((1.0f / 6.0f) * ep.surfaceArea);
			}
			UI *= UScale;
			float gScale = 2.0f * UScale;
			if (Options == CubeOptions::Skin) {
				const float C[3] = { 0.1095f, 14.95f, 4.595f };
				float IM;
				if constexpr (sizeof(Vec) == sizeof(vec2)) {
					IM = UI - 2.0f;
				} else {
					IM = UI - 3.0f;
				}
				UI = max(0.0001f, C[0] * IM + C[1] * IM * IM + C[2] * IM * IM * IM);
				gScale *= C[0] + 2.0f * C[1] * IM + 3.0f * C[2] * IM * IM;
			}

			float alpha = settings.compliance / (ep.volume * dt * dt);
			float wgg = PPw * gScale * gScale;
			float lambda = -2.0f * UI / (wgg + 2.0f * UI * alpha);
			if (settings.damping > 0.0f && RayleighType < Rayleigh_Post) {
				float gV = 0.0f;
				for (uint32_t n = 0; n < Nodes; n++) { gV += dot(P[n], Vec(X[is[n]] - O[is[n]])); }
				gV *= gScale;
				if (RayleighType == Rayleigh_Paper) {
					float gamma = settings.damping / dt;
					lambda = (-2.0f * UI - gamma * gV) / (wgg * (1.0f + gamma) + 2.0f * UI * alpha);
				} else if (RayleighType == Rayleigh_Limit) {
					float invBeta = dt * alpha / settings.damping;
					float A = wgg + 2.0f * UI * invBeta;
					float b = -gV - wgg * lambda;
					b *= A / max(A, 4.0f * wgg);
					lambda += b / A;
				}
			}
			if (dampingMode == DampingMode::Off) {
				float PScale = lambda * gScale;
				for (uint32_t n = 0; n < Nodes; n++) { P[n] *= 1.0f + w[is[n]] * PScale; }
			} else if (RayleighType >= Rayleigh_Post) {
				float invBeta = dt * alpha / settings.damping;
				wgg += 1.0e-22f;
				float gV = 0.0f;
				for (uint32_t n = 0; n < Nodes; n++) { gV += dot(P[n], Vec(V[is[n]])); }
				float lambda = -(gScale * gV) / (2.0f * UI * invBeta + wgg);
				for (uint32_t n = 0; n < Nodes; n++) { V[is[n]] += Dvec((w[is[n]] * lambda * gScale) * P[n]); }
			}
		}

		// Apply volume
		if constexpr (sizeof(Vec) == sizeof(vec2)) {
			mat2 F = transpose(mat2(
				-P[0] + P[1] - P[3] + P[2],
				-P[0] - P[1] + P[3] + P[2]));
			mat2 adjF = adjugate(F) * 1.0f / 4.0f;
			float detF = determinantFromAdjugate(F, adjF);
			float J = detF;
			vec2 gA = -adjF[0] - adjF[1];
			vec2 gB = +adjF[0] - adjF[1];
			float wgg =
				(w[is[0]] + w[is[2]]) * dot(gA, gA) +
				(w[is[1]] + w[is[3]]) * dot(gB, gB);
			float alpha = ep.volume / (lameLambda * dt * dt);
			float lambda = -(J - a * ep.volume) / (wgg + alpha);
			if (settings.damping > 0.0f && RayleighType < Rayleigh_Post) {
				float gV =
					dot((P[0] - Vec(O[is[0]] - centroid)) - (P[2] - Vec(O[is[2]] - centroid)), gA) +
					dot((P[1] - Vec(O[is[1]] - centroid)) - (P[3] - Vec(O[is[3]] - centroid)), gB);
				if (RayleighType == Rayleigh_Paper) {
					float gamma = settings.damping / dt;
					lambda = (-(J - a * ep.volume) - gamma * gV) / (wgg * (1.0f + gamma) + alpha);
				} else if (RayleighType == Rayleigh_Limit) {
					float invBeta = dt * alpha / settings.damping;
					float A = wgg + invBeta;
					float b = -gV - wgg * lambda;
					b *= A / max(A, 4.0f * wgg);
					lambda += b / A;
				}
			}

			if (dampingMode == DampingMode::On) {
				float invBeta = dt * alpha / settings.damping;
				wgg += 1.0e-22f;
				float gV =
					dot(Vec(V[is[0]]) - Vec(V[is[2]]), gA) +
					dot(Vec(V[is[1]]) - Vec(V[is[3]]), gB);
				float lambda = -gV / (invBeta + wgg);
				V[is[0]] += Dvec(w[is[0]] * lambda * gA);
				V[is[2]] -= Dvec(w[is[2]] * lambda * gA);
				V[is[1]] += Dvec(w[is[1]] * lambda * gB);
				V[is[3]] -= Dvec(w[is[3]] * lambda * gB);
			} else {
				P[0] += w[is[0]] * lambda * gA;
				P[2] -= w[is[2]] * lambda * gA;
				P[1] += w[is[1]] * lambda * gB;
				P[3] -= w[is[3]] * lambda * gB;
			}
		} else {
			mat3 F = transpose(mat3(
				-P[0] + P[1] - P[2] + P[3] - P[4] + P[5] - P[6] + P[7],
				-P[0] - P[1] + P[2] + P[3] - P[4] - P[5] + P[6] + P[7],
				-P[0] - P[1] - P[2] - P[3] + P[4] + P[5] + P[6] + P[7]));
			mat3 adjF = adjugate(F) * 1.0f / 64.0f;
			float detF = determinantFromAdjugate(F, adjF);
			float J = detF;
			vec3 gA = -adjF[0] - adjF[1] - adjF[2];
			vec3 gB = +adjF[0] - adjF[1] - adjF[2];
			vec3 gC = -adjF[0] + adjF[1] - adjF[2];
			vec3 gD = +adjF[0] + adjF[1] - adjF[2];
			float wgg =
				(w[is[0]] + w[is[7]]) * dot(gA, gA) +
				(w[is[1]] + w[is[6]]) * dot(gB, gB) +
				(w[is[2]] + w[is[5]]) * dot(gC, gC) +
				(w[is[3]] + w[is[4]]) * dot(gD, gD);
			float alpha = ep.volume / (lameLambda * dt * dt);
			float lambda = -(J - a * ep.volume) / (wgg + alpha);
			if (settings.damping > 0.0f && RayleighType < Rayleigh_Post) {
				float gV =
					dot((P[0] - Vec(O[is[0]] - centroid)) - (P[7] - Vec(O[is[7]] - centroid)), gA) +
					dot((P[1] - Vec(O[is[1]] - centroid)) - (P[6] - Vec(O[is[6]] - centroid)), gB) +
					dot((P[2] - Vec(O[is[2]] - centroid)) - (P[5] - Vec(O[is[5]] - centroid)), gC) +
					dot((P[3] - Vec(O[is[3]] - centroid)) - (P[4] - Vec(O[is[4]] - centroid)), gD);
				if (RayleighType == Rayleigh_Paper) {
					float gamma = settings.damping / dt;
					lambda = (-(J - a * ep.volume) - gamma * gV) / (wgg * (1.0f + gamma) + alpha);
				} else if (RayleighType == Rayleigh_Limit) {
					float invBeta = dt * alpha / settings.damping;
					float A = wgg + invBeta;
					float b = -gV - wgg * lambda;
					b *= A / max(A, 4.0f * wgg);
					lambda += b / A;
				}
			}

			if (dampingMode == DampingMode::On) {
				float invBeta = dt * alpha / settings.damping;
				wgg += 1.0e-22f;
				float gV =
					dot(Vec(V[is[0]]) - Vec(V[is[7]]), gA) +
					dot(Vec(V[is[1]]) - Vec(V[is[6]]), gB) +
					dot(Vec(V[is[2]]) - Vec(V[is[5]]), gC) +
					dot(Vec(V[is[3]]) - Vec(V[is[4]]), gD);
				float lambda = -gV / (invBeta + wgg);
				V[is[0]] += Dvec(w[is[0]] * lambda * gA);
				V[is[7]] -= Dvec(w[is[7]] * lambda * gA);
				V[is[1]] += Dvec(w[is[1]] * lambda * gB);
				V[is[6]] -= Dvec(w[is[6]] * lambda * gB);
				V[is[2]] += Dvec(w[is[2]] * lambda * gC);
				V[is[5]] -= Dvec(w[is[5]] * lambda * gC);
				V[is[3]] += Dvec(w[is[3]] * lambda * gD);
				V[is[4]] -= Dvec(w[is[4]] * lambda * gD);
			} else {
				P[0] += w[is[0]] * lambda * gA;
				P[7] -= w[is[7]] * lambda * gA;
				P[1] += w[is[1]] * lambda * gB;
				P[6] -= w[is[6]] * lambda * gB;
				P[2] += w[is[2]] * lambda * gC;
				P[5] -= w[is[5]] * lambda * gC;
				P[3] += w[is[3]] * lambda * gD;
				P[4] -= w[is[4]] * lambda * gD;
			}
		}

		// Write back to world-space
		if (dampingMode == DampingMode::Off) {
			for (uint32_t n = 0; n < Nodes; n++) { X[is[n]] = Dvec(P[n]) + centroid; }
		}
	}
}

template<typename Dvec, typename ElementParams, uint32_t Nodes>
inline void SolveVolumeOnly(float dt, Dvec* X, const Dvec* O, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, const Settings& settings) {
	using Vec = typename Dvec::vec;

	float comp = settings.compliance * ep.volume;
	float damp = 0.0f;

	Vec P[Nodes - 1];
	for (uint32_t i = 0; i < Nodes - 1; i++) { P[i] = Vec(X[is[i]] - X[is[Nodes - 1]]); }

	float U = 0.0f;
	Vec g[Nodes];
	for (uint32_t n = 0; n < Nodes; n++) { g[n] = Vec(0.0f); }

	const uint32_t Points = ElementParams::PointsLo;
	for (uint32_t p = 0; p < Points; p++) {
		auto F = CalculateDeformationGradient<Points>(ep, P, p);
		float weight = CalculateQuadratureWeight<Points>(ep, p);
		auto adjF = adjugate(F);
		float J = determinantFromAdjugate(F, adjF);
		U += weight * (J - 1.0f) * (J - 1.0f);
		auto GJ = (weight * 2.0f * (J - 1.0f)) * adjF;
		ApplyEnergyGradient<Points>(ep, g, GJ, p);
	}
	for (uint32_t n = 0; n < Nodes - 1; n++) { g[Nodes - 1] -= g[n]; }

	EnergyXpbdConstrain(Nodes, X, O, w, is, U, g, dt, comp, damp, Rayleigh_Post);
}

//-----------------------------------------------------------------------------
// Element solve functions
template<typename Dvec, typename ElementParams, uint32_t Nodes>
void TSolveElement(float dt, Dvec* X, const Dvec* O, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, const Settings& settings) {
	uint32_t energyFunction = (settings.flags >> Settings_EnergyBit) & Settings_EnergyMask;
	switch (energyFunction) {
	case Energy_Pixar: SolveElementPixar<PixarOptions::Full>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_PixarReduced: SolveElementPixar<PixarOptions::Reduced>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_PixarSel: SolveElementPixar<PixarOptions::Selective>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_Mixed: SolveElementMixed<MixedOptions::Mixed>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_MixedSel: SolveElementMixed<MixedOptions::MixedSelective>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_YeohSkin: SolveElementMixed<MixedOptions::YeohSkin>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_YeohSkinSel: SolveElementMixed<MixedOptions::YeohSkinSelective>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_YeohSkinFast: SolveElementMixed<MixedOptions::YeohSkinFast>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_CubeNeo: SolveElementCube<CubeOptions::Neo>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	case Energy_CubeSkin: SolveElementCube<CubeOptions::Skin>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings); break;
	default:
		SolveElementMixed<MixedOptions::MixedSelective>(DampingMode::Off, dt, X, O, (Dvec*)0, w, is, ep, settings);
		break;
	}
}
void SolveElement(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[3], const ElementParamsLinearTri& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[6], const ElementParamsQuadraticTri& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[4], const ElementParamsLinearTet& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[10], const ElementParamsQuadraticTet& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[4], const ElementParamsLinearQuad& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[9], const ElementParamsQuadraticQuad& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[8], const ElementParamsLinearHex& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }
void SolveElement(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[27], const ElementParamsQuadraticHex& ep, const Settings& settings) { TSolveElement(dt, X, O, w, is, ep, settings); }

void SolveElementVolume(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[3], const ElementParamsLinearTri& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[6], const ElementParamsQuadraticTri& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[4], const ElementParamsLinearTet& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[10], const ElementParamsQuadraticTet& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[4], const ElementParamsLinearQuad& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[9], const ElementParamsQuadraticQuad& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[8], const ElementParamsLinearHex& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }
void SolveElementVolume(float dt, dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[27], const ElementParamsQuadraticHex& ep, const Settings& settings) { SolveVolumeOnly(dt, X, O, w, is, ep, settings); }

//-----------------------------------------------------------------------------
// Element damp functions
template<typename Dvec, typename ElementParams, uint32_t Nodes>
void TDampElement(float dt, Dvec* X, Dvec* V, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, const Settings& settings) {
	if (settings.damping <= 0.0f) { return; }
	uint32_t energyFunction = (settings.flags >> Settings_EnergyBit) & Settings_EnergyMask;
	switch (energyFunction) {
	case Energy_Pixar: SolveElementPixar<PixarOptions::Full>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_PixarReduced: SolveElementPixar<PixarOptions::Reduced>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_PixarSel: SolveElementPixar<PixarOptions::Selective>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_Mixed: SolveElementMixed<MixedOptions::Mixed>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_MixedSel: SolveElementMixed<MixedOptions::MixedSelective>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_YeohSkin: SolveElementMixed<MixedOptions::YeohSkin>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_YeohSkinSel: SolveElementMixed<MixedOptions::YeohSkinSelective>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_YeohSkinFast: SolveElementMixed<MixedOptions::YeohSkinFast>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_CubeNeo: SolveElementCube<CubeOptions::Neo>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	case Energy_CubeSkin: SolveElementCube<CubeOptions::Skin>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings); break;
	default:
		SolveElementMixed<MixedOptions::MixedSelective>(DampingMode::On, dt, X, (const Dvec*)0, V, w, is, ep, settings);
		break;
	}
}
void DampElement(float dt, dvec2* X, dvec2* V, const float* w, const uint32_t(&is)[3], const ElementParamsLinearTri& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec2* X, dvec2* V, const float* w, const uint32_t(&is)[6], const ElementParamsQuadraticTri& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec3* X, dvec3* V, const float* w, const uint32_t(&is)[4], const ElementParamsLinearTet& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec3* X, dvec3* V, const float* w, const uint32_t(&is)[10], const ElementParamsQuadraticTet& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec2* X, dvec2* V, const float* w, const uint32_t(&is)[4], const ElementParamsLinearQuad& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec2* X, dvec2* V, const float* w, const uint32_t(&is)[9], const ElementParamsQuadraticQuad& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec3* X, dvec3* V, const float* w, const uint32_t(&is)[8], const ElementParamsLinearHex& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }
void DampElement(float dt, dvec3* X, dvec3* V, const float* w, const uint32_t(&is)[27], const ElementParamsQuadraticHex& ep, const Settings& settings) { TDampElement(dt, X, V, w, is, ep, settings); }

//-----------------------------------------------------------------------------
// Partial element solves for continuous pressure constraints
template<typename Dvec, typename Vec, typename ElementParams, uint32_t Nodes>
void TCalculateElementEnergyAndGradients(float dt, const Dvec* X, const Dvec* O, const float* w, const uint32_t(&is)[Nodes], const ElementParams& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], Vec* (&__restrict g)[2][Nodes]) {
	Vec P[Nodes - 1];
	for (uint32_t i = 0; i < Nodes - 1; i++) { P[i] = Vec(X[is[i]] - X[is[Nodes - 1]]); }

	uint32_t energyFunction = (settings.flags >> Settings_EnergyBit) & Settings_EnergyMask;

	const bool IsFirstOrder = ElementParams::PointsLo == 1;
	const uint32_t Div = IsFirstOrder ? Nodes : ElementParams::PointsLo;
	float elemWeight = (ep.volume / (float)Div) / oneRingVolume;

	// First order simplexes just return invariants
	if constexpr (IsFirstOrder && (ElementParams::Shape == FemShape::Tri || ElementParams::Shape == FemShape::Tet)) {
		float I1;
		Vec gI1[Nodes];
		CalculateIncompressibleNeoHookeanEnergyAndGradients(ep.ic, P, &I1, gI1);
		U[0] += elemWeight * I1;
		for (uint32_t n = 0; n < Nodes; n++) { *g[0][n] += elemWeight * gI1[n]; }

		if constexpr (ElementParams::Shape == FemShape::Tri) {
			float J = 1.0f / ep.volume * 0.5f * (P[0].x * P[1].y - P[0].y * P[1].x);
			U[1] += elemWeight * J;
			*g[1][0] += elemWeight / ep.volume * 0.5f * vec2(P[1].y, -P[1].x);
			*g[1][1] += elemWeight / ep.volume * 0.5f * vec2(-P[0].y, P[0].x);
			*g[1][2] += elemWeight / ep.volume * 0.5f * vec2(P[0].y - P[1].y, P[1].x - P[0].x);
		} else {
			mat3 PP = mat3(vec3(P[0][0], P[1][0], P[2][0]), vec3(P[0][1], P[1][1], P[2][1]), vec3(P[0][2], P[1][2], P[2][2]));
			mat3 adj = adjugate(PP);
			float J = 1.0f / ep.volume * (1.0f / 6.0f) * determinantFromAdjugate(PP, adj);
			U[1] += elemWeight * J;
			*g[1][0] += elemWeight / ep.volume * (1.0f / 6.0f) * adj[0];
			*g[1][1] += elemWeight / ep.volume * (1.0f / 6.0f) * adj[1];
			*g[1][2] += elemWeight / ep.volume * (1.0f / 6.0f) * adj[2];
			*g[1][3] += elemWeight / ep.volume * (1.0f / 6.0f) * (-adj[0] - adj[1] - adj[2]);
		}

		return;
	}

	// Otherwise, integrate full energies

	// Generate the I1 term
	if (energyFunction == Energy_ContinuousSkin) {
		Vec gI[Nodes];
		for (uint32_t i = 0; i < Nodes - 1; i++) { gI[i] = Vec(0.0f); }

		const uint32_t Points = ElementParams::PointsHi;
		for (uint32_t p = 0; p < Points; p++) {
			auto F = CalculateDeformationGradient<Points>(ep, P, p);
			float weight = elemWeight * CalculateQuadratureWeight<Points>(ep, p);

			const float CSkin[3] = { 0.1095f, 14.95f, 4.595f };
			const float(&C)[3] = CSkin;
			float IM;
			if constexpr (sizeof(Vec) == sizeof(vec2)) {
				IM = dot(F[0], F[0]) + dot(F[1], F[1]) - 2.0f;
			} else {
				IM = dot(F[0], F[0]) + dot(F[1], F[1]) + dot(F[2], F[2]) - 3.0f;
			}
			U[0] += weight * (C[0] * IM + C[1] * IM * IM + C[2] * IM * IM * IM);
			auto yeohG = (weight * (2.0f * C[0] + 4.0f * C[1] * IM + 6.0f * C[2] * IM * IM)) * transpose(F);
			ApplyEnergyGradient<Points>(ep, gI, yeohG, p);
		}
		for (uint32_t n = 0; n < Nodes - 1; n++) { *g[0][n] += gI[n]; *g[0][Nodes - 1] -= gI[n]; }
	} else {
		float UI1;
		Vec gI1[Nodes];
		CalculateIncompressibleNeoHookeanEnergyAndGradients(ep.ic, P, &UI1, gI1);
		U[0] += elemWeight * UI1;
		for (uint32_t n = 0; n < Nodes; n++) { *g[0][n] += elemWeight * gI1[n]; }
	}

	// Generate the (J - a)^2 term
	{
		bool isPix = energyFunction == Energy_ContinuousPixar;
		float a = isPix ? (1.0f + (1.0f - 2.0f * settings.poissonsRatio)) : (1.0f / (2.0f * settings.poissonsRatio));

		Vec gJ[Nodes];
		for (uint32_t i = 0; i < Nodes - 1; i++) { gJ[i] = Vec(0.0f); }

		const uint32_t Points = ElementParams::PointsLo;
		for (uint32_t p = 0; p < Points; p++) {
			auto F = CalculateDeformationGradient<Points>(ep, P, p);
			float weight = elemWeight * CalculateQuadratureWeight<Points>(ep, p);

			auto adjF = adjugate(F);
			float J = determinantFromAdjugate(F, adjF);
			U[1] += weight * (J - a) * (J - a);
			auto GJ = (weight * 2.0f * (J - a)) * adjF;
			ApplyEnergyGradient<Points>(ep, gJ, GJ, p);
		}
		for (uint32_t i = 0; i < Nodes - 1; i++) { *g[1][i] += gJ[i]; *g[1][Nodes - 1] -= gJ[i]; }
	}
}
void CalculateElementEnergyAndGradients(float dt, const dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[3], const ElementParamsLinearTri& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec2* (&__restrict g)[2][3]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[6], const ElementParamsQuadraticTri& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec2* (&__restrict g)[2][6]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[4], const ElementParamsLinearQuad& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec2* (&__restrict g)[2][4]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec2* X, const dvec2* O, const float* w, const uint32_t(&is)[9], const ElementParamsQuadraticQuad& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec2* (&__restrict g)[2][9]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[4], const ElementParamsLinearTet& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec3* (&__restrict g)[2][4]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[10], const ElementParamsQuadraticTet& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec3* (&__restrict g)[2][10]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[8], const ElementParamsLinearHex& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec3* (&__restrict g)[2][8]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }
void CalculateElementEnergyAndGradients(float dt, const dvec3* X, const dvec3* O, const float* w, const uint32_t(&is)[27], const ElementParamsQuadraticHex& ep, uint32_t pressurePoint, float oneRingVolume, const Settings& settings, float(&__restrict U)[2], vec3* (&__restrict g)[2][27]) { TCalculateElementEnergyAndGradients(dt, X, O, w, is, ep, pressurePoint, oneRingVolume, settings, U, g); }

//-----------------------------------------------------------------------------
// Volume functions
template<typename Vec, typename Dvec, typename ElementParams, uint32_t Nodes>
float TCalculateElementVolume(const Dvec* X, const uint32_t(&is)[Nodes], const ElementParams& ep) {
	Vec P[Nodes - 1];
	for (uint32_t i = 0; i < Nodes - 1; i++) {
		P[i] = Vec(X[is[i]] - X[is[Nodes - 1]]);
	}

	float scale = 0.0f;

	const uint32_t Points = ElementParams::PointsHi;
	for (uint32_t p = 0; p < Points; p++) {
		auto F = CalculateDeformationGradient<Points>(ep, P, p);
		float weight = CalculateQuadratureWeight<Points>(ep, p);
		float localScale = determinant(F);
		scale += weight * localScale;
	}

	return ep.volume * scale;
}
float CalculateElementVolume(const dvec2* X, const uint32_t(&is)[3], const ElementParamsLinearTri& ep) { return (1.0f / 2.0f) * determinant(mat2(vec2(X[is[0]] - X[is[2]]), vec2(X[is[1]] - X[is[2]]))); }
float CalculateElementVolume(const dvec2* X, const uint32_t(&is)[6], const ElementParamsQuadraticTri& ep) { return TCalculateElementVolume<vec2>(X, is, ep); }
float CalculateElementVolume(const dvec3* X, const uint32_t(&is)[4], const ElementParamsLinearTet& ep) { return (1.0f / 6.0f) * determinant(mat3(vec3(X[is[0]] - X[is[3]]), vec3(X[is[1]] - X[is[3]]), vec3(X[is[2]] - X[is[3]]))); }
float CalculateElementVolume(const dvec3* X, const uint32_t(&is)[10], const ElementParamsQuadraticTet& ep) { return TCalculateElementVolume<vec3>(X, is, ep); }
float CalculateElementVolume(const dvec2* X, const uint32_t(&is)[4], const ElementParamsLinearQuad& ep) { return TCalculateElementVolume<vec2>(X, is, ep); }
float CalculateElementVolume(const dvec2* X, const uint32_t(&is)[9], const ElementParamsQuadraticQuad& ep) { return TCalculateElementVolume<vec2>(X, is, ep); }
float CalculateElementVolume(const dvec3* X, const uint32_t(&is)[8], const ElementParamsLinearHex& ep) { return TCalculateElementVolume<vec3>(X, is, ep); }
float CalculateElementVolume(const dvec3* X, const uint32_t(&is)[27], const ElementParamsQuadraticHex& ep) { return TCalculateElementVolume<vec3>(X, is, ep); }
